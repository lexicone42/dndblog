---
/**
 * DM Party Tracker Page
 * Real-time view of party status during sessions.
 * Shows HP, conditions, features, and death saves for all active PCs.
 * Uses WebSocket for instant updates with polling fallback.
 */

import { getCollection, type CollectionEntry } from 'astro:content';
import BaseLayout from '@layouts/BaseLayout.astro';

const apiUrl = import.meta.env.PUBLIC_DM_NOTES_API_URL || '';
const wsUrl = import.meta.env.PUBLIC_WS_URL || '';

// Type for party member data
interface PartyFeature {
  name: string;
  max: number;
  recharge: string;
}

interface SpellSlot {
  level: number;
  max: number;
  current: number;
}

interface PartyMember {
  slug: string;
  name: string;
  level: number;
  class: string;
  subclass: string | null;
  race?: string;
  maxHp: number;
  currentHp: number;
  features: PartyFeature[];
  spellSlots: SpellSlot[];
}

// Get all active PC characters
const characters = await getCollection('characters');
const partyMembers: PartyMember[] = characters
  .filter((c: CollectionEntry<'characters'>) => c.data.subtype === 'pc' && c.data.status === 'active')
  .sort((a: CollectionEntry<'characters'>, b: CollectionEntry<'characters'>) => a.data.name.localeCompare(b.data.name))
  .map((c: CollectionEntry<'characters'>) => ({
    slug: c.id,
    name: c.data.name,
    level: c.data.level || 1,
    class: c.data.class || 'Unknown',
    subclass: c.data.subclass || null,
    race: c.data.race,
    maxHp: c.data.combat?.maxHp ?? 10,
    currentHp: c.data.combat?.hp ?? c.data.combat?.maxHp ?? 10,
    features: (c.data.features || [])
      .filter((f: { uses?: unknown }) => f.uses)
      .map((f: { name: string; uses: { current?: number; max?: number; recharge?: string } }) => ({
        name: f.name,
        max: f.uses?.max ?? 0,
        recharge: f.uses?.recharge ?? 'long-rest',
      })),
    spellSlots: (c.data.spellcasting?.spellSlots || []).map((s: { level: number; total?: number; max?: number; expended?: number; current?: number }) => {
      // Support both formats: {total, expended} and {max, current}
      const max = s.total ?? s.max ?? 0;
      const expended = s.expended ?? 0;
      const current = s.current ?? (max - expended);
      return { level: s.level, max, current };
    }),
  }));
---

<BaseLayout
  title="Party Tracker - DM Dashboard"
  description="Real-time party status tracking for the Dungeon Master."
>
  <div class="party-tracker">
    <!-- Auth Gate -->
    <div id="auth-gate" class="auth-gate">
      <div class="auth-content">
        <div class="auth-icon">
          <svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
            <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
            <circle cx="9" cy="7" r="4"></circle>
            <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
            <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
          </svg>
        </div>
        <h1 class="auth-title">Party Tracker</h1>
        <p class="auth-description">Sign in with your DM account to view party status.</p>
        <button id="cognito-login-btn" class="auth-btn">
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
            <circle cx="12" cy="7" r="4"></circle>
          </svg>
          Sign in with Account
        </button>
        <p id="auth-error" class="auth-error" style="display: none;">Access denied. DM role required.</p>
      </div>
    </div>

    <!-- Tracker Content -->
    <div id="tracker-content" class="tracker-content" style="display: none;">
      <header class="tracker-header">
        <div class="header-main">
          <a href="/dm" class="back-link">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <polyline points="15 18 9 12 15 6"></polyline>
            </svg>
            DM Dashboard
          </a>
          <h1 class="tracker-title">Party Status</h1>
          <div class="header-actions">
            <!-- Connection Status -->
            <div id="connection-status" class="connection-status connection-status--disconnected" title="WebSocket disconnected">
              <span class="connection-dot"></span>
              <span class="connection-text">Disconnected</span>
            </div>
            <!-- End Session Button -->
            <button id="end-session-btn" class="end-session-btn" title="Clear all session state">
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                <line x1="9" y1="9" x2="15" y2="15"></line>
                <line x1="15" y1="9" x2="9" y2="15"></line>
              </svg>
              End Session
            </button>
            <!-- Refresh Button -->
            <div id="refresh-indicator" class="refresh-indicator">
              <span class="refresh-time">Updated just now</span>
              <button id="refresh-btn" class="refresh-btn" title="Refresh now">
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <polyline points="23 4 23 10 17 10"></polyline>
                  <polyline points="1 20 1 14 7 14"></polyline>
                  <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
                </svg>
              </button>
            </div>
          </div>
        </div>
      </header>

      <div id="party-grid" class="party-grid">
        {partyMembers.map((member) => (
          <div class="character-card" data-slug={member.slug}>
            <div class="card-header">
              <div class="character-identity">
                <h2 class="character-name">{member.name}</h2>
                <span class="character-class">
                  Level {member.level} {member.class}
                  {member.subclass && ` (${member.subclass})`}
                </span>
              </div>
              <div class="draft-status" data-status="none">
                <span class="status-badge status-badge--none">No draft</span>
              </div>
            </div>

            <div class="hp-section">
              <div class="hp-header">
                <span class="hp-label">HP</span>
                <span class="hp-value">{member.currentHp}/{member.maxHp}</span>
              </div>
              <div class="hp-bar" data-max={member.maxHp}>
                <div class="hp-bar-fill" style={`width: ${(member.currentHp / member.maxHp) * 100}%`}></div>
              </div>
            </div>

            <!-- Death Saves (hidden by default) -->
            <div class="death-saves" style="display: none;">
              <span class="death-saves-warning">DEATH SAVES</span>
              <div class="death-saves-display">
                <span class="death-label">Successes:</span>
                <span class="death-pips death-pips--success">
                  <span class="pip"></span><span class="pip"></span><span class="pip"></span>
                </span>
                <span class="death-label">Failures:</span>
                <span class="death-pips death-pips--failure">
                  <span class="pip"></span><span class="pip"></span><span class="pip"></span>
                </span>
              </div>
            </div>

            <!-- Conditions -->
            <div class="conditions-section">
              <div class="conditions-list">
                <span class="no-conditions">No conditions</span>
              </div>
            </div>

            <!-- Spell Slots (if any) -->
            {member.spellSlots.length > 0 && (
              <div class="spell-slots-section">
                <div class="spell-slots-header">Spell Slots</div>
                <div class="spell-slots-list">
                  {member.spellSlots.map((slot) => (
                    <div class="spell-slot-item" data-level={slot.level}>
                      <span class="slot-level">L{slot.level}</span>
                      <span class="slot-pips" data-max={slot.max}>
                        {[...Array(slot.max)].map(() => (
                          <span class="pip pip--available"></span>
                        ))}
                      </span>
                    </div>
                  ))}
                </div>
              </div>
            )}

            <!-- Features (if any) -->
            {member.features.length > 0 && (
              <div class="features-section">
                <div class="features-list">
                  {member.features.map((feature) => (
                    <div class="feature-item" data-feature={feature.name} data-recharge={feature.recharge}>
                      <span class="feature-name">{feature.name}</span>
                      <span class="feature-pips" data-max={feature.max}>
                        {[...Array(feature.max)].map(() => (
                          <span class="pip pip--available"></span>
                        ))}
                      </span>
                    </div>
                  ))}
                </div>
              </div>
            )}

            <a href={`/campaign/characters/${member.slug}`} class="view-character-link">
              View Character
              <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path>
                <circle cx="12" cy="7" r="4"></circle>
              </svg>
            </a>
          </div>
        ))}
      </div>

      <footer class="tracker-footer">
        <span class="auto-refresh-note">Auto-refreshes every 30 seconds</span>
        <button id="logout-btn" class="logout-btn">
          <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path>
            <polyline points="16 17 21 12 16 7"></polyline>
            <line x1="21" y1="12" x2="9" y2="12"></line>
          </svg>
          Sign Out
        </button>
      </footer>
    </div>
  </div>
</BaseLayout>

<script is:inline define:vars={{ apiUrl, wsUrl, partyMembers }}>
(function() {
  var COGNITO_AUTH_KEY = 'dndblog-cognito-auth';
  var API_URL = apiUrl;
  var WS_URL = wsUrl;
  var REFRESH_INTERVAL = 60000; // 60 seconds (reduced - WebSocket is primary)
  var RECONNECT_DELAY = 3000; // 3 seconds
  var refreshTimer = null;
  var lastRefresh = Date.now();
  var ws = null;
  var wsReconnectTimer = null;

  // Auth helpers
  function getAuthState() {
    var cognitoAuth = localStorage.getItem(COGNITO_AUTH_KEY);
    if (cognitoAuth) {
      try {
        var auth = JSON.parse(cognitoAuth);
        if (auth.roles && auth.roles.isDm) {
          if (auth.expiresAt && auth.expiresAt < Date.now()) {
            localStorage.removeItem(COGNITO_AUTH_KEY);
            return null;
          }
          return { isDm: true, accessToken: auth.accessToken };
        }
      } catch (e) {
        localStorage.removeItem(COGNITO_AUTH_KEY);
      }
    }
    return null;
  }

  function getAuthHeaders() {
    var auth = getAuthState();
    if (!auth) return {};
    return { 'Authorization': 'Bearer ' + auth.accessToken };
  }

  function getLoginUrl() {
    var clientId = '3fcqll16v2fv44o0u4ecjgpcai';
    var domain = 'chronicles-mawframe.auth.us-east-1.amazoncognito.com';
    var callbackUrl = encodeURIComponent(window.location.origin + '/auth/callback');
    var state = encodeURIComponent('/dm/party-tracker');
    return 'https://' + domain + '/login?client_id=' + clientId +
      '&response_type=code&scope=openid+email+profile&redirect_uri=' + callbackUrl + '&state=' + state;
  }

  // DOM elements
  var authGate = document.getElementById('auth-gate');
  var trackerContent = document.getElementById('tracker-content');
  var authError = document.getElementById('auth-error');
  var refreshBtn = document.getElementById('refresh-btn');
  var refreshTime = document.querySelector('.refresh-time');
  var connectionStatus = document.getElementById('connection-status');
  var endSessionBtn = document.getElementById('end-session-btn');
  var cognitoLoginBtn = document.getElementById('cognito-login-btn');

  // ============================================
  // WebSocket Connection
  // ============================================

  function connectWebSocket() {
    if (!WS_URL) {
      console.log('WebSocket URL not configured, using polling only');
      return;
    }

    var auth = getAuthState();
    if (!auth) return;

    // Close existing connection
    if (ws) {
      ws.close();
    }

    try {
      ws = new WebSocket(WS_URL + '?token=' + encodeURIComponent(auth.accessToken));

      ws.onopen = function() {
        console.log('WebSocket connected');
        updateConnectionStatus('connected');
        // Clear any reconnect timer
        if (wsReconnectTimer) {
          clearTimeout(wsReconnectTimer);
          wsReconnectTimer = null;
        }
      };

      ws.onmessage = function(event) {
        try {
          var data = JSON.parse(event.data);
          console.log('WebSocket message:', data);

          if (data.action === 'session_update') {
            // Player updated their session state - refresh that character
            if (data.sessionData) {
              applySessionDataToCard(data.character, data.sessionData);
              lastRefresh = Date.now();
              updateRefreshTime();
            } else {
              // Full refresh as fallback
              loadDrafts();
            }
          } else if (data.action === 'session_ended') {
            // Session ended - reset all cards to default
            console.log('Session ended, clearing all state');
            resetAllCards();
            lastRefresh = Date.now();
            updateRefreshTime();
          } else if (data.action === 'pong') {
            // Heartbeat response
            console.log('Pong received');
          }
        } catch (e) {
          console.error('Failed to parse WebSocket message:', e);
        }
      };

      ws.onclose = function(event) {
        console.log('WebSocket disconnected:', event.code, event.reason);
        updateConnectionStatus('disconnected');
        ws = null;

        // Auto-reconnect after delay
        if (!wsReconnectTimer) {
          wsReconnectTimer = setTimeout(function() {
            wsReconnectTimer = null;
            connectWebSocket();
          }, RECONNECT_DELAY);
        }
      };

      ws.onerror = function(error) {
        console.error('WebSocket error:', error);
        updateConnectionStatus('disconnected');
      };
    } catch (e) {
      console.error('Failed to create WebSocket:', e);
      updateConnectionStatus('disconnected');
    }
  }

  function disconnectWebSocket() {
    if (wsReconnectTimer) {
      clearTimeout(wsReconnectTimer);
      wsReconnectTimer = null;
    }
    if (ws) {
      ws.close();
      ws = null;
    }
    updateConnectionStatus('disconnected');
  }

  function updateConnectionStatus(status) {
    if (!connectionStatus) return;

    connectionStatus.className = 'connection-status connection-status--' + status;
    var text = connectionStatus.querySelector('.connection-text');
    if (text) {
      text.textContent = status === 'connected' ? 'Live' : 'Disconnected';
    }
    connectionStatus.title = status === 'connected' ? 'WebSocket connected - receiving live updates' : 'WebSocket disconnected - using polling';
  }

  // ============================================
  // End Session
  // ============================================

  async function endSession() {
    var auth = getAuthState();
    if (!auth || !API_URL) return;

    if (!confirm('End the session? This will clear all player session state.')) {
      return;
    }

    try {
      var response = await fetch(API_URL + '/dm/end-session', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          ...getAuthHeaders()
        },
      });

      if (response.ok) {
        var data = await response.json();
        console.log('Session ended:', data);
        // Cards will be reset via WebSocket broadcast, but reset locally too
        resetAllCards();
      } else {
        console.error('Failed to end session:', response.status);
        alert('Failed to end session. Please try again.');
      }
    } catch (error) {
      console.error('Error ending session:', error);
      alert('Error ending session. Please try again.');
    }
  }

  if (endSessionBtn) {
    endSessionBtn.addEventListener('click', endSession);
  }

  // ============================================
  // Authentication
  // ============================================

  function checkAuth() {
    var auth = getAuthState();
    if (auth && auth.isDm) {
      showTracker();
      loadDrafts();
      startAutoRefresh();
      connectWebSocket();
    }
  }

  function showTracker() {
    authGate.style.display = 'none';
    trackerContent.style.display = 'block';
  }

  function showAuthGate() {
    authGate.style.display = 'flex';
    trackerContent.style.display = 'none';
  }

  cognitoLoginBtn.addEventListener('click', function() {
    window.location.href = getLoginUrl();
  });

  document.getElementById('logout-btn').addEventListener('click', function() {
    stopAutoRefresh();
    disconnectWebSocket();
    localStorage.removeItem(COGNITO_AUTH_KEY);
    showAuthGate();
  });

  // ============================================
  // Auto-refresh (fallback when WebSocket disconnected)
  // ============================================

  function startAutoRefresh() {
    if (refreshTimer) clearInterval(refreshTimer);
    refreshTimer = setInterval(function() {
      loadDrafts();
    }, REFRESH_INTERVAL);
  }

  function stopAutoRefresh() {
    if (refreshTimer) {
      clearInterval(refreshTimer);
      refreshTimer = null;
    }
  }

  function updateRefreshTime() {
    var seconds = Math.floor((Date.now() - lastRefresh) / 1000);
    if (seconds < 5) {
      refreshTime.textContent = 'Updated just now';
    } else if (seconds < 60) {
      refreshTime.textContent = 'Updated ' + seconds + 's ago';
    } else {
      var minutes = Math.floor(seconds / 60);
      refreshTime.textContent = 'Updated ' + minutes + 'm ago';
    }
  }

  setInterval(updateRefreshTime, 5000);

  refreshBtn.addEventListener('click', function() {
    refreshBtn.classList.add('spinning');
    loadDrafts().then(function() {
      setTimeout(function() {
        refreshBtn.classList.remove('spinning');
      }, 500);
    });
  });

  // ============================================
  // Load and display drafts
  // ============================================

  async function loadDrafts() {
    var auth = getAuthState();
    if (!auth || !API_URL) return;

    try {
      var response = await fetch(API_URL + '/player/drafts', {
        method: 'GET',
        headers: getAuthHeaders(),
      });

      if (!response.ok) {
        console.error('Failed to load drafts');
        return;
      }

      var data = await response.json();
      lastRefresh = Date.now();
      updateRefreshTime();
      applyDraftsToCards(data.drafts || []);

    } catch (error) {
      console.error('Error loading drafts:', error);
    }
  }

  function applyDraftsToCards(drafts) {
    // Create a map for quick lookup
    var draftMap = {};
    drafts.forEach(function(d) {
      draftMap[d.characterSlug] = d;
    });

    // Update each character card
    partyMembers.forEach(function(member) {
      var card = document.querySelector('.character-card[data-slug="' + member.slug + '"]');
      if (!card) return;

      var draft = draftMap[member.slug];

      // Update draft status badge
      var statusBadge = card.querySelector('.status-badge');
      if (draft) {
        statusBadge.className = 'status-badge status-badge--draft';
        statusBadge.textContent = 'Has draft';
      } else {
        statusBadge.className = 'status-badge status-badge--none';
        statusBadge.textContent = 'No draft';
      }

      // Update HP
      var hp = draft && draft.combat ? draft.combat.hp : member.currentHp;
      var tempHp = draft && draft.combat ? (draft.combat.tempHp || 0) : 0;
      var maxHp = member.maxHp;

      var hpValue = card.querySelector('.hp-value');
      hpValue.textContent = hp + '/' + maxHp + (tempHp > 0 ? ' (+' + tempHp + ')' : '');

      var hpBarFill = card.querySelector('.hp-bar-fill');
      var percent = Math.min(100, (hp / maxHp) * 100);
      hpBarFill.style.width = percent + '%';

      // Update HP bar color
      var hpBar = card.querySelector('.hp-bar');
      hpBar.classList.remove('hp-bar--critical', 'hp-bar--warning', 'hp-bar--healthy');
      if (percent <= 0) {
        hpBar.classList.add('hp-bar--dead');
      } else if (percent <= 25) {
        hpBar.classList.add('hp-bar--critical');
      } else if (percent <= 50) {
        hpBar.classList.add('hp-bar--warning');
      } else {
        hpBar.classList.add('hp-bar--healthy');
      }

      // Update death saves
      var deathSavesSection = card.querySelector('.death-saves');
      if (hp === 0 && draft && draft.deathSaves) {
        deathSavesSection.style.display = 'block';
        var successPips = card.querySelectorAll('.death-pips--success .pip');
        var failurePips = card.querySelectorAll('.death-pips--failure .pip');

        successPips.forEach(function(pip, i) {
          pip.classList.toggle('pip--filled', i < draft.deathSaves.successes);
        });
        failurePips.forEach(function(pip, i) {
          pip.classList.toggle('pip--filled', i < draft.deathSaves.failures);
        });
      } else {
        deathSavesSection.style.display = 'none';
      }

      // Update conditions
      var conditionsList = card.querySelector('.conditions-list');
      while (conditionsList.firstChild) {
        conditionsList.removeChild(conditionsList.firstChild);
      }

      // Support both field names for backwards compatibility
      var conditions = draft ? (draft.conditions || draft.activeConditions || []) : [];
      if (conditions.length === 0) {
        var noConditions = document.createElement('span');
        noConditions.className = 'no-conditions';
        noConditions.textContent = 'No conditions';
        conditionsList.appendChild(noConditions);
      } else {
        conditions.forEach(function(condition) {
          var tag = document.createElement('span');
          tag.className = 'condition-tag' + (condition.beneficial ? ' condition-tag--beneficial' : '');
          tag.textContent = condition.name;
          conditionsList.appendChild(tag);
        });
      }

      // Update spell slots
      var spellSlotsSection = card.querySelector('.spell-slots-section');
      if (spellSlotsSection && draft && draft.spellSlots) {
        draft.spellSlots.forEach(function(draftSlot) {
          var slotItem = card.querySelector('.spell-slot-item[data-level="' + draftSlot.level + '"]');
          if (slotItem) {
            var pips = slotItem.querySelectorAll('.pip');
            pips.forEach(function(pip, i) {
              pip.classList.toggle('pip--available', i < draftSlot.current);
              pip.classList.toggle('pip--used', i >= draftSlot.current);
            });
          }
        });
      }

      // Update features
      var featuresSection = card.querySelector('.features-section');
      if (featuresSection && draft && draft.features) {
        draft.features.forEach(function(draftFeature) {
          var featureItem = card.querySelector('.feature-item[data-feature="' + draftFeature.name + '"]');
          if (featureItem) {
            var pips = featureItem.querySelectorAll('.pip');
            pips.forEach(function(pip, i) {
              pip.classList.toggle('pip--available', i < draftFeature.current);
              pip.classList.toggle('pip--used', i >= draftFeature.current);
            });
          }
        });
      }
    });
  }

  // ============================================
  // Single card update (for WebSocket messages)
  // ============================================

  function applySessionDataToCard(characterSlug, sessionData) {
    var card = document.querySelector('.character-card[data-slug="' + characterSlug + '"]');
    if (!card) return;

    var member = partyMembers.find(function(m) { return m.slug === characterSlug; });
    if (!member) return;

    // Update status badge
    var statusBadge = card.querySelector('.status-badge');
    statusBadge.className = 'status-badge status-badge--draft';
    statusBadge.textContent = 'Active';

    // Update HP
    var hp = sessionData.combat ? sessionData.combat.hp : member.currentHp;
    var tempHp = sessionData.combat ? (sessionData.combat.tempHp || 0) : 0;
    var maxHp = member.maxHp;

    var hpValue = card.querySelector('.hp-value');
    hpValue.textContent = hp + '/' + maxHp + (tempHp > 0 ? ' (+' + tempHp + ')' : '');

    var hpBarFill = card.querySelector('.hp-bar-fill');
    var percent = Math.min(100, (hp / maxHp) * 100);
    hpBarFill.style.width = percent + '%';

    // Update HP bar color
    var hpBar = card.querySelector('.hp-bar');
    hpBar.classList.remove('hp-bar--critical', 'hp-bar--warning', 'hp-bar--healthy', 'hp-bar--dead');
    if (percent <= 0) {
      hpBar.classList.add('hp-bar--dead');
    } else if (percent <= 25) {
      hpBar.classList.add('hp-bar--critical');
    } else if (percent <= 50) {
      hpBar.classList.add('hp-bar--warning');
    } else {
      hpBar.classList.add('hp-bar--healthy');
    }

    // Update death saves
    var deathSavesSection = card.querySelector('.death-saves');
    if (hp === 0 && sessionData.deathSaves) {
      deathSavesSection.style.display = 'block';
      var successPips = card.querySelectorAll('.death-pips--success .pip');
      var failurePips = card.querySelectorAll('.death-pips--failure .pip');

      successPips.forEach(function(pip, i) {
        pip.classList.toggle('pip--filled', i < sessionData.deathSaves.successes);
      });
      failurePips.forEach(function(pip, i) {
        pip.classList.toggle('pip--filled', i < sessionData.deathSaves.failures);
      });
    } else {
      deathSavesSection.style.display = 'none';
    }

    // Update conditions
    var conditionsList = card.querySelector('.conditions-list');
    while (conditionsList.firstChild) {
      conditionsList.removeChild(conditionsList.firstChild);
    }

    // Support both field names for backwards compatibility
    var conditions = sessionData.conditions || sessionData.activeConditions || [];
    if (conditions.length === 0) {
      var noConditions = document.createElement('span');
      noConditions.className = 'no-conditions';
      noConditions.textContent = 'No conditions';
      conditionsList.appendChild(noConditions);
    } else {
      conditions.forEach(function(condition) {
        var tag = document.createElement('span');
        tag.className = 'condition-tag' + (condition.beneficial ? ' condition-tag--beneficial' : '');
        tag.textContent = condition.name;
        conditionsList.appendChild(tag);
      });
    }

    // Update spell slots
    var spellSlotsSection = card.querySelector('.spell-slots-section');
    if (spellSlotsSection && sessionData.spellSlots) {
      sessionData.spellSlots.forEach(function(slot) {
        var slotItem = card.querySelector('.spell-slot-item[data-level="' + slot.level + '"]');
        if (slotItem) {
          var pips = slotItem.querySelectorAll('.pip');
          pips.forEach(function(pip, i) {
            pip.classList.toggle('pip--available', i < slot.current);
            pip.classList.toggle('pip--used', i >= slot.current);
          });
        }
      });
    }

    // Update features
    var featuresSection = card.querySelector('.features-section');
    if (featuresSection && sessionData.features) {
      sessionData.features.forEach(function(feature) {
        var featureItem = card.querySelector('.feature-item[data-feature="' + feature.name + '"]');
        if (featureItem) {
          var pips = featureItem.querySelectorAll('.pip');
          pips.forEach(function(pip, i) {
            pip.classList.toggle('pip--available', i < feature.current);
            pip.classList.toggle('pip--used', i >= feature.current);
          });
        }
      });
    }

    // Visual flash to indicate update
    card.classList.add('card-updated');
    setTimeout(function() {
      card.classList.remove('card-updated');
    }, 1000);
  }

  // ============================================
  // Reset all cards (for session end)
  // ============================================

  function resetAllCards() {
    partyMembers.forEach(function(member) {
      var card = document.querySelector('.character-card[data-slug="' + member.slug + '"]');
      if (!card) return;

      // Reset status badge
      var statusBadge = card.querySelector('.status-badge');
      statusBadge.className = 'status-badge status-badge--none';
      statusBadge.textContent = 'No draft';

      // Reset HP to baseline
      var hpValue = card.querySelector('.hp-value');
      hpValue.textContent = member.currentHp + '/' + member.maxHp;

      var hpBarFill = card.querySelector('.hp-bar-fill');
      var percent = Math.min(100, (member.currentHp / member.maxHp) * 100);
      hpBarFill.style.width = percent + '%';

      // Reset HP bar color
      var hpBar = card.querySelector('.hp-bar');
      hpBar.classList.remove('hp-bar--critical', 'hp-bar--warning', 'hp-bar--dead');
      hpBar.classList.add('hp-bar--healthy');

      // Hide death saves
      var deathSavesSection = card.querySelector('.death-saves');
      deathSavesSection.style.display = 'none';

      // Reset conditions
      var conditionsList = card.querySelector('.conditions-list');
      while (conditionsList.firstChild) {
        conditionsList.removeChild(conditionsList.firstChild);
      }
      var noConditions = document.createElement('span');
      noConditions.className = 'no-conditions';
      noConditions.textContent = 'No conditions';
      conditionsList.appendChild(noConditions);

      // Reset spell slots
      var spellSlotsSection = card.querySelector('.spell-slots-section');
      if (spellSlotsSection) {
        member.spellSlots.forEach(function(slot) {
          var slotItem = card.querySelector('.spell-slot-item[data-level="' + slot.level + '"]');
          if (slotItem) {
            var pips = slotItem.querySelectorAll('.pip');
            pips.forEach(function(pip) {
              pip.classList.add('pip--available');
              pip.classList.remove('pip--used');
            });
          }
        });
      }

      // Reset features
      var featuresSection = card.querySelector('.features-section');
      if (featuresSection) {
        member.features.forEach(function(feature) {
          var featureItem = card.querySelector('.feature-item[data-feature="' + feature.name + '"]');
          if (featureItem) {
            var pips = featureItem.querySelectorAll('.pip');
            pips.forEach(function(pip) {
              pip.classList.add('pip--available');
              pip.classList.remove('pip--used');
            });
          }
        });
      }
    });
  }

  // ============================================
  // Initialize
  // ============================================

  checkAuth();
})();
</script>

<style>
  .party-tracker {
    min-height: 80vh;
  }

  /* Auth Gate */
  .auth-gate {
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 70vh;
    padding: var(--space-xl);
  }

  .auth-content {
    text-align: center;
    max-width: 400px;
  }

  .auth-icon {
    color: var(--color-accent);
    margin-bottom: var(--space-lg);
  }

  .auth-title {
    font-family: var(--font-display);
    font-size: var(--text-2xl);
    color: var(--color-gold);
    margin: 0 0 var(--space-sm);
  }

  .auth-description {
    color: var(--color-text-secondary);
    margin: 0 0 var(--space-xl);
  }

  .auth-form {
    display: flex;
    gap: var(--space-sm);
  }

  .auth-input {
    flex: 1;
    padding: var(--space-md);
    border: 2px solid var(--color-border);
    border-radius: var(--radius-md);
    background: var(--color-bg-secondary);
    color: var(--color-text);
    font-size: var(--text-base);
  }

  .auth-input:focus {
    outline: none;
    border-color: var(--color-accent);
  }

  .auth-btn {
    display: flex;
    align-items: center;
    gap: var(--space-xs);
    padding: var(--space-md) var(--space-lg);
    background: var(--color-accent);
    color: white;
    border: none;
    border-radius: var(--radius-md);
    font-weight: 600;
    cursor: pointer;
    transition: all var(--transition-fast);
  }

  .auth-btn:hover {
    background: var(--color-accent-hover);
  }

  .auth-error {
    color: var(--color-error);
    margin-top: var(--space-md);
    font-size: var(--text-sm);
  }

  .visually-hidden {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }

  /* Tracker Content */
  .tracker-content {
    padding: var(--space-lg);
    max-width: 1200px;
    margin: 0 auto;
  }

  .tracker-header {
    margin-bottom: var(--space-xl);
  }

  .header-main {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: var(--space-lg);
    flex-wrap: wrap;
  }

  .back-link {
    display: inline-flex;
    align-items: center;
    gap: var(--space-xs);
    color: var(--color-text-secondary);
    text-decoration: none;
    font-size: var(--text-sm);
    transition: color var(--transition-fast);
  }

  .back-link:hover {
    color: var(--color-accent);
  }

  .tracker-title {
    font-family: var(--font-display);
    font-size: var(--text-2xl);
    color: var(--color-gold);
    margin: 0;
    flex: 1;
    text-align: center;
  }

  .header-actions {
    display: flex;
    align-items: center;
    gap: var(--space-md);
  }

  /* Connection Status */
  .connection-status {
    display: flex;
    align-items: center;
    gap: var(--space-xs);
    font-size: var(--text-sm);
    padding: var(--space-xs) var(--space-sm);
    border-radius: var(--radius-md);
    transition: all var(--transition-fast);
  }

  .connection-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    transition: all var(--transition-fast);
  }

  .connection-status--connected {
    background: rgba(16, 185, 129, 0.1);
    color: var(--color-success, #10b981);
  }

  .connection-status--connected .connection-dot {
    background: var(--color-success, #10b981);
    box-shadow: 0 0 8px rgba(16, 185, 129, 0.6);
    animation: pulse-connected 2s ease-in-out infinite;
  }

  .connection-status--disconnected {
    background: rgba(239, 68, 68, 0.1);
    color: var(--color-error);
  }

  .connection-status--disconnected .connection-dot {
    background: var(--color-error);
  }

  @keyframes pulse-connected {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
  }

  /* End Session Button */
  .end-session-btn {
    display: flex;
    align-items: center;
    gap: var(--space-xs);
    padding: var(--space-sm) var(--space-md);
    background: transparent;
    border: 1px solid var(--color-error);
    border-radius: var(--radius-md);
    color: var(--color-error);
    font-size: var(--text-sm);
    font-weight: 500;
    cursor: pointer;
    transition: all var(--transition-fast);
  }

  .end-session-btn:hover {
    background: var(--color-error);
    color: white;
  }

  /* Card update animation */
  .card-updated {
    animation: card-flash 1s ease-out;
  }

  @keyframes card-flash {
    0% {
      box-shadow: 0 0 0 2px var(--color-accent);
    }
    100% {
      box-shadow: none;
    }
  }

  .refresh-indicator {
    display: flex;
    align-items: center;
    gap: var(--space-sm);
  }

  .refresh-time {
    font-size: var(--text-sm);
    color: var(--color-text-muted);
  }

  .refresh-btn {
    background: var(--color-bg-tertiary);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-md);
    padding: var(--space-sm);
    color: var(--color-text-secondary);
    cursor: pointer;
    transition: all var(--transition-fast);
  }

  .refresh-btn:hover {
    background: var(--color-bg-secondary);
    border-color: var(--color-accent);
    color: var(--color-accent);
  }

  .refresh-btn.spinning svg {
    animation: spin 0.5s linear;
  }

  @keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
  }

  /* Party Grid */
  .party-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
    gap: var(--space-lg);
    margin-bottom: var(--space-xl);
  }

  .character-card {
    background: var(--color-bg-secondary);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-xl);
    padding: var(--space-lg);
    display: flex;
    flex-direction: column;
    gap: var(--space-md);
    transition: all var(--transition-fast);
  }

  .character-card:hover {
    border-color: var(--color-gold);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  }

  .card-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    gap: var(--space-md);
  }

  .character-identity {
    flex: 1;
  }

  .character-name {
    font-family: var(--font-display);
    font-size: var(--text-lg);
    color: var(--color-gold);
    margin: 0 0 var(--space-xs);
  }

  .character-class {
    font-size: var(--text-sm);
    color: var(--color-text-secondary);
  }

  .status-badge {
    padding: 2px 8px;
    border-radius: var(--radius-sm);
    font-size: var(--text-xs);
    font-weight: 600;
    text-transform: uppercase;
  }

  .status-badge--none {
    background: var(--color-bg-tertiary);
    color: var(--color-text-muted);
  }

  .status-badge--draft {
    background: var(--color-info, #3b82f6);
    color: white;
  }

  /* HP Section */
  .hp-section {
    padding: var(--space-sm) 0;
  }

  .hp-header {
    display: flex;
    justify-content: space-between;
    margin-bottom: var(--space-xs);
  }

  .hp-label {
    font-size: var(--text-sm);
    font-weight: 600;
    color: var(--color-text-secondary);
  }

  .hp-value {
    font-size: var(--text-sm);
    font-weight: 700;
    color: var(--color-accent);
    font-variant-numeric: tabular-nums;
  }

  .hp-bar {
    height: 12px;
    background: var(--color-bg-tertiary);
    border-radius: var(--radius-lg);
    overflow: hidden;
  }

  .hp-bar-fill {
    height: 100%;
    background: linear-gradient(180deg, #34d399 0%, #10b981 100%);
    transition: width 0.3s ease, background 0.3s ease;
  }

  .hp-bar--healthy .hp-bar-fill {
    background: linear-gradient(180deg, #34d399 0%, #10b981 100%);
    box-shadow: 0 0 8px rgba(16, 185, 129, 0.4);
  }

  .hp-bar--warning .hp-bar-fill {
    background: linear-gradient(180deg, #fbbf24 0%, #f59e0b 100%);
    box-shadow: 0 0 8px rgba(245, 158, 11, 0.4);
  }

  .hp-bar--critical .hp-bar-fill {
    background: linear-gradient(180deg, #f87171 0%, #ef4444 100%);
    box-shadow: 0 0 12px rgba(239, 68, 68, 0.6);
    animation: pulse-critical 1s ease-in-out infinite;
  }

  .hp-bar--dead .hp-bar-fill {
    width: 0 !important;
  }

  @keyframes pulse-critical {
    0%, 100% { box-shadow: 0 0 12px rgba(239, 68, 68, 0.6); }
    50% { box-shadow: 0 0 20px rgba(239, 68, 68, 0.9); }
  }

  /* Death Saves */
  .death-saves {
    background: rgba(239, 68, 68, 0.1);
    border: 1px solid var(--color-error);
    border-radius: var(--radius-md);
    padding: var(--space-sm);
    animation: death-appear 0.3s ease-out;
  }

  @keyframes death-appear {
    from { opacity: 0; transform: translateY(-5px); }
    to { opacity: 1; transform: translateY(0); }
  }

  .death-saves-warning {
    display: block;
    text-align: center;
    font-size: var(--text-xs);
    font-weight: 700;
    color: var(--color-error);
    margin-bottom: var(--space-xs);
    letter-spacing: 0.1em;
  }

  .death-saves-display {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--space-sm);
    font-size: var(--text-xs);
  }

  .death-label {
    color: var(--color-text-muted);
  }

  .death-pips {
    display: flex;
    gap: 4px;
  }

  .death-pips .pip {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    border: 2px solid var(--color-text-muted);
    background: transparent;
  }

  .death-pips--success .pip.pip--filled {
    background: var(--color-success, #10b981);
    border-color: var(--color-success, #10b981);
  }

  .death-pips--failure .pip.pip--filled {
    background: var(--color-error);
    border-color: var(--color-error);
  }

  /* Conditions */
  .conditions-section {
    min-height: 28px;
  }

  .conditions-list {
    display: flex;
    flex-wrap: wrap;
    gap: var(--space-xs);
  }

  .no-conditions {
    font-size: var(--text-xs);
    color: var(--color-text-muted);
    font-style: italic;
  }

  .condition-tag {
    padding: 2px 8px;
    background: var(--color-error);
    color: white;
    font-size: var(--text-xs);
    font-weight: 500;
    border-radius: var(--radius-sm);
  }

  .condition-tag--beneficial {
    background: var(--color-success, #10b981);
  }

  /* Spell Slots */
  .spell-slots-section {
    border-top: 1px solid var(--color-border);
    padding-top: var(--space-sm);
  }

  .spell-slots-header {
    font-size: var(--text-xs);
    font-weight: 600;
    color: var(--color-gold);
    margin-bottom: var(--space-xs);
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }

  .spell-slots-list {
    display: flex;
    flex-wrap: wrap;
    gap: var(--space-sm);
  }

  .spell-slot-item {
    display: flex;
    align-items: center;
    gap: var(--space-xs);
    font-size: var(--text-xs);
  }

  .slot-level {
    color: var(--color-text-muted);
    min-width: 20px;
    font-weight: 500;
  }

  .slot-pips {
    display: flex;
    gap: 3px;
  }

  .slot-pips .pip {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    border: 1.5px solid var(--color-gold);
  }

  .slot-pips .pip--available {
    background: var(--color-gold);
  }

  .slot-pips .pip--used {
    background: transparent;
    opacity: 0.4;
  }

  /* Features */
  .features-section {
    border-top: 1px solid var(--color-border);
    padding-top: var(--space-sm);
  }

  .features-list {
    display: flex;
    flex-direction: column;
    gap: var(--space-xs);
  }

  .feature-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    font-size: var(--text-xs);
  }

  .feature-name {
    color: var(--color-text-secondary);
  }

  .feature-pips {
    display: flex;
    gap: 4px;
  }

  .feature-pips .pip {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    border: 2px solid var(--color-gold);
  }

  .feature-pips .pip--available {
    background: var(--color-gold);
  }

  .feature-pips .pip--used {
    background: transparent;
    opacity: 0.4;
  }

  /* View Link */
  .view-character-link {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--space-xs);
    padding: var(--space-sm);
    background: var(--color-bg-tertiary);
    border-radius: var(--radius-md);
    color: var(--color-text-secondary);
    font-size: var(--text-sm);
    text-decoration: none;
    transition: all var(--transition-fast);
    margin-top: auto;
  }

  .view-character-link:hover {
    background: var(--color-bg);
    color: var(--color-accent);
  }

  /* Footer */
  .tracker-footer {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding-top: var(--space-lg);
    border-top: 1px solid var(--color-border);
  }

  .auto-refresh-note {
    font-size: var(--text-sm);
    color: var(--color-text-muted);
  }

  .logout-btn {
    display: inline-flex;
    align-items: center;
    gap: var(--space-xs);
    padding: var(--space-sm) var(--space-md);
    background: transparent;
    border: 1px solid var(--color-border);
    border-radius: var(--radius-md);
    color: var(--color-text-muted);
    font-size: var(--text-sm);
    cursor: pointer;
    transition: all var(--transition-fast);
  }

  .logout-btn:hover {
    border-color: var(--color-error);
    color: var(--color-error);
  }

  @media (max-width: 640px) {
    .tracker-content {
      padding: var(--space-md);
    }

    .header-main {
      flex-direction: column;
      text-align: center;
    }

    .back-link {
      align-self: flex-start;
    }

    .refresh-indicator {
      align-self: flex-end;
    }

    .party-grid {
      grid-template-columns: 1fr;
    }

    .tracker-footer {
      flex-direction: column;
      gap: var(--space-md);
    }
  }
</style>
