---
/**
 * Campaign Character Session Tracker
 * Cognito-protected page for players to track their character during sessions.
 * URL: /campaign/character/{character-slug}
 */

import { getCollection, type CollectionEntry } from 'astro:content';
import BaseLayout from '@layouts/BaseLayout.astro';

const { slug } = Astro.params;
const apiUrl = import.meta.env.PUBLIC_DM_NOTES_API_URL || '';

// Type for party member data
interface PartyFeature {
  name: string;
  max: number;
  current?: number;
  recharge: string;
  description?: string;
}

interface SpellSlot {
  level: number;
  max: number;
  current?: number;
}

interface AbilityScores {
  str: number;
  dex: number;
  con: number;
  int: number;
  wis: number;
  cha: number;
}

interface Skill {
  name: string;
  proficient: boolean;
  expertise?: boolean;
  bonus: number;
}

interface Spellcasting {
  ability: string;
  spellSaveDC: number;
  spellAttackBonus: number;
  cantrips: string[];
  preparedSpells: string[];
}

interface PartyMember {
  slug: string;
  name: string;
  level: number;
  class: string;
  subclass: string | null;
  race?: string;
  maxHp: number;
  currentHp: number;
  ac: number;
  proficiencyBonus: number;
  abilityScores: AbilityScores;
  savingThrows: Record<string, boolean>;
  skills: Skill[];
  senses: {
    passivePerception: number;
    passiveInvestigation?: number;
    passiveInsight?: number;
  };
  spellcasting: Spellcasting | null;
  features: PartyFeature[];
  spellSlots: SpellSlot[];
  player?: string;
}

// Get all active PC characters
const characters = await getCollection('characters');
const partyMembers: PartyMember[] = characters
  .filter((c: CollectionEntry<'characters'>) => c.data.subtype === 'pc' && c.data.status === 'active')
  .sort((a: CollectionEntry<'characters'>, b: CollectionEntry<'characters'>) => a.data.name.localeCompare(b.data.name))
  .map((c: CollectionEntry<'characters'>) => ({
    slug: c.id,
    name: c.data.name,
    level: c.data.level || 1,
    class: c.data.class || 'Unknown',
    subclass: c.data.subclass || null,
    race: c.data.race,
    player: c.data.player,
    maxHp: c.data.combat?.maxHp ?? 10,
    currentHp: c.data.combat?.hp ?? c.data.combat?.maxHp ?? 10,
    ac: c.data.combat?.ac ?? 10,
    proficiencyBonus: c.data.combat?.proficiencyBonus ?? 2,
    abilityScores: c.data.abilityScores ?? { str: 10, dex: 10, con: 10, int: 10, wis: 10, cha: 10 },
    savingThrows: c.data.savingThrows ?? {},
    skills: (c.data.skills || []).map((s: { name: string; proficient?: boolean; expertise?: boolean; bonus?: number }) => ({
      name: s.name,
      proficient: s.proficient ?? false,
      expertise: s.expertise ?? false,
      bonus: s.bonus ?? 0,
    })),
    senses: {
      passivePerception: c.data.senses?.passivePerception ?? 10,
      passiveInvestigation: c.data.senses?.passiveInvestigation,
      passiveInsight: c.data.senses?.passiveInsight,
    },
    spellcasting: c.data.spellcasting ? {
      ability: c.data.spellcasting.ability ?? 'int',
      spellSaveDC: c.data.spellcasting.spellSaveDC ?? 10,
      spellAttackBonus: c.data.spellcasting.spellAttackBonus ?? 0,
      cantrips: c.data.spellcasting.cantrips ?? [],
      preparedSpells: c.data.spellcasting.preparedSpells ?? [],
    } : null,
    features: (c.data.features || [])
      .filter((f: { uses?: unknown }) => f.uses)
      .map((f: { name: string; description?: string; uses: { current?: number; max?: number; recharge?: string } }) => ({
        name: f.name,
        description: f.description,
        max: f.uses?.max ?? 0,
        current: f.uses?.current ?? f.uses?.max ?? 0,
        recharge: f.uses?.recharge ?? 'long-rest',
      })),
    spellSlots: (c.data.spellcasting?.spellSlots || []).map((s: { level: number; total?: number; max?: number; expended?: number; current?: number }) => {
      // Support both formats: {total, expended} and {max, current}
      const max = s.total ?? s.max ?? 0;
      const expended = s.expended ?? 0;
      const current = s.current ?? (max - expended);
      return { level: s.level, max, current };
    }),
  }));

// Find the character from the URL slug
const targetCharacter = partyMembers.find(c => c.slug === slug);

// Standard D&D 5e conditions
const dndConditions = [
  'Blinded', 'Charmed', 'Deafened', 'Frightened', 'Grappled',
  'Incapacitated', 'Invisible', 'Paralyzed', 'Petrified', 'Poisoned',
  'Prone', 'Restrained', 'Stunned', 'Unconscious', 'Exhaustion'
];

// Generate static paths for all characters
export async function getStaticPaths() {
  const characters = await getCollection('characters');
  return characters
    .filter((c: CollectionEntry<'characters'>) => c.data.subtype === 'pc' && c.data.status === 'active')
    .map((c: CollectionEntry<'characters'>) => ({
      params: { slug: c.id },
    }));
}

const pageTitle = targetCharacter
  ? `${targetCharacter.name} - Session Tracker`
  : 'Session Tracker';
---

<BaseLayout
  title={pageTitle}
  description="Track your character's session state in real-time."
>
  <div class="campaign-hub">
    <!-- Character Not Found -->
    {!targetCharacter && (
      <section class="not-found-section">
        <div class="not-found-container">
          <div class="not-found-icon">
            <svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
              <circle cx="12" cy="12" r="10"></circle>
              <line x1="12" y1="8" x2="12" y2="12"></line>
              <line x1="12" y1="16" x2="12.01" y2="16"></line>
            </svg>
          </div>
          <h1>Character Not Found</h1>
          <p>The character "{slug}" was not found in the party.</p>
          <a href="/party" class="back-link">View Party Status &rarr;</a>
        </div>
      </section>
    )}

    {targetCharacter && (
      <>
        <!-- Auth Section (shown when not authenticated) -->
        <section id="auth-section" class="auth-section">
          <div class="auth-container">
            <div class="auth-header">
              <div class="auth-icon">
                <svg xmlns="http://www.w3.org/2000/svg" width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
                  <circle cx="9" cy="7" r="4"></circle>
                  <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
                  <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
                </svg>
              </div>
              <h1 class="auth-title">{targetCharacter.name}</h1>
              <p class="auth-subtitle">Sign in to track this character during sessions</p>
            </div>

            <div class="auth-methods">
              <div class="auth-method">
                <p class="method-description">Sign in with your account to access the session tracker</p>
                <button id="sso-btn" class="sso-btn">
                  <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4"></path>
                    <polyline points="10 17 15 12 10 7"></polyline>
                    <line x1="15" y1="12" x2="3" y2="12"></line>
                  </svg>
                  Sign in with Account
                </button>
                <p id="sso-error" class="auth-error" style="display: none;"></p>
                <p id="sso-unavailable" class="auth-notice" style="display: none;">
                  Account sign-in is not yet configured. Check back soon!
                </p>
              </div>
            </div>
          </div>
        </section>

        <!-- Session Tracker (shown after auth) -->
        <section id="tracker-section" class="tracker-section" style="display: none;">
          <header class="tracker-header">
            <div class="header-content">
              <h1 id="character-title" class="tracker-title">{targetCharacter.name}</h1>
              <p id="user-greeting" class="tracker-subtitle">Welcome back!</p>
            </div>
            <div class="header-actions">
              <span id="save-status" class="save-status">
                <span class="save-dot"></span>
                <span class="save-text">Saved</span>
              </span>
              <button id="sign-out-btn" class="sign-out-btn">Sign Out</button>
            </div>
          </header>

          <!-- Access Denied Message (shown when user doesn't own this character) -->
          <div id="access-denied-message" class="access-denied-message" style="display: none;">
            <div class="message-icon">
              <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect>
                <path d="M7 11V7a5 5 0 0 1 10 0v4"></path>
              </svg>
            </div>
            <h2>Not Your Character</h2>
            <p>You can only edit the session tracker for your assigned character.</p>
            <a id="your-character-link" href="/party" class="party-link">Go to Your Character &rarr;</a>
          </div>

          <!-- Session Tracker Content -->
          <div id="tracker-content" class="tracker-content" style="display: none;">

            <!-- Compact Combat Dashboard -->
            <div class="combat-dashboard">
              <!-- HP Block -->
              <div class="stat-block stat-block--hp">
                <div class="stat-label">HP</div>
                <div class="hp-inline">
                  <input type="number" id="current-hp" class="hp-input-compact" min="0" />
                  <span class="hp-sep">/</span>
                  <span id="max-hp" class="hp-max-compact">0</span>
                </div>
                <div id="hp-bar" class="hp-bar-mini">
                  <div id="hp-bar-fill" class="hp-bar-fill-mini"></div>
                </div>
              </div>

              <!-- AC Block -->
              <div class="stat-block stat-block--ac">
                <div class="stat-label">AC</div>
                <div id="ac-value" class="stat-value">10</div>
              </div>

              <!-- Spell Save DC (if caster) -->
              <div id="spell-dc-block" class="stat-block stat-block--dc" style="display: none;">
                <div class="stat-label">Spell DC</div>
                <div id="spell-dc-value" class="stat-value">10</div>
              </div>

              <!-- Concentration Tracker -->
              <div id="concentration-block" class="stat-block stat-block--conc" style="display: none;">
                <div class="stat-label">Conc.</div>
                <button id="concentration-btn" class="conc-btn" title="Click to clear concentration">
                  <span id="conc-spell-name" class="conc-spell">—</span>
                </button>
              </div>

              <!-- Proficiency Bonus -->
              <div class="stat-block stat-block--prof">
                <div class="stat-label">Prof</div>
                <div id="prof-value" class="stat-value">+2</div>
              </div>
            </div>

            <!-- HP Quick Actions & Temp HP Row -->
            <div class="hp-actions-row">
              <div class="temp-hp">
                <span class="temp-label">Temp HP:</span>
                <input type="number" id="temp-hp" class="temp-hp-input" min="0" value="0" />
              </div>
              <div class="hp-quick-actions">
                <button class="hp-btn hp-btn--damage" data-delta="-5">-5</button>
                <button class="hp-btn hp-btn--damage" data-delta="-1">-1</button>
                <button class="hp-btn hp-btn--heal" data-delta="+1">+1</button>
                <button class="hp-btn hp-btn--heal" data-delta="+5">+5</button>
              </div>
            </div>

            <!-- Ability Scores -->
            <div class="abilities-row">
              <div class="ability" data-ability="str">
                <div class="ability-name">STR</div>
                <div id="str-mod" class="ability-mod">+0</div>
                <div id="str-score" class="ability-score">10</div>
              </div>
              <div class="ability" data-ability="dex">
                <div class="ability-name">DEX</div>
                <div id="dex-mod" class="ability-mod">+0</div>
                <div id="dex-score" class="ability-score">10</div>
              </div>
              <div class="ability" data-ability="con">
                <div class="ability-name">CON</div>
                <div id="con-mod" class="ability-mod">+0</div>
                <div id="con-score" class="ability-score">10</div>
              </div>
              <div class="ability" data-ability="int">
                <div class="ability-name">INT</div>
                <div id="int-mod" class="ability-mod">+0</div>
                <div id="int-score" class="ability-score">10</div>
              </div>
              <div class="ability" data-ability="wis">
                <div class="ability-name">WIS</div>
                <div id="wis-mod" class="ability-mod">+0</div>
                <div id="wis-score" class="ability-score">10</div>
              </div>
              <div class="ability" data-ability="cha">
                <div class="ability-name">CHA</div>
                <div id="cha-mod" class="ability-mod">+0</div>
                <div id="cha-score" class="ability-score">10</div>
              </div>
            </div>

            <!-- Death Saves Section (only visible at 0 HP) -->
            <div id="death-saves-card" class="tracker-card death-saves-card" style="display: none;">
              <div class="card-header">
                <h2 class="card-title death-title">
                  <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="12" cy="12" r="10"></circle>
                    <line x1="12" y1="8" x2="12" y2="12"></line>
                    <line x1="12" y1="16" x2="12.01" y2="16"></line>
                  </svg>
                  Death Saves
                </h2>
              </div>
              <div class="death-saves-grid">
                <div class="death-row">
                  <span class="death-label">Successes</span>
                  <div class="death-pips" id="success-pips">
                    <button class="pip" data-type="success" data-index="0"></button>
                    <button class="pip" data-type="success" data-index="1"></button>
                    <button class="pip" data-type="success" data-index="2"></button>
                  </div>
                </div>
                <div class="death-row">
                  <span class="death-label">Failures</span>
                  <div class="death-pips death-pips--failure" id="failure-pips">
                    <button class="pip" data-type="failure" data-index="0"></button>
                    <button class="pip" data-type="failure" data-index="1"></button>
                    <button class="pip" data-type="failure" data-index="2"></button>
                  </div>
                </div>
              </div>
              <button id="reset-death-saves" class="reset-death-saves">Reset Death Saves</button>
            </div>

            <!-- Conditions Section -->
            <div class="tracker-card conditions-card">
              <div class="card-header">
                <h2 class="card-title">
                  <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path>
                    <line x1="12" y1="9" x2="12" y2="13"></line>
                    <line x1="12" y1="17" x2="12.01" y2="17"></line>
                  </svg>
                  Conditions
                </h2>
              </div>
              <div id="active-conditions" class="active-conditions">
                <span class="no-conditions">No active conditions</span>
              </div>
              <div class="conditions-grid">
                {dndConditions.map((condition) => (
                  <button class="condition-btn" data-condition={condition}>
                    {condition}
                  </button>
                ))}
              </div>
            </div>

            <!-- Spellcasting Section (if character has spells) -->
            <div id="spellcasting-section" class="spellcasting-section" style="display: none;">
              <!-- Spell Slots with Rest Dropdown -->
              <div class="tracker-card spell-slots-card">
                <div class="card-header card-header--with-action">
                  <h2 class="card-title">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>
                    </svg>
                    Spell Slots
                  </h2>
                  <select id="rest-select" class="rest-select">
                    <option value="">Recover...</option>
                    <option value="short">Short Rest</option>
                    <option value="long">Long Rest</option>
                  </select>
                </div>
                <div id="spell-slots-grid" class="spell-slots-grid">
                  <!-- Populated by JavaScript using safe DOM methods -->
                </div>
              </div>

              <!-- Cantrips -->
              <div id="cantrips-card" class="tracker-card cantrips-card" style="display: none;">
                <div class="card-header collapsible-header" data-collapse="cantrips">
                  <h2 class="card-title card-title--small">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"></path>
                    </svg>
                    Cantrips
                    <span class="collapse-arrow">▼</span>
                  </h2>
                </div>
                <div id="cantrips-list" class="spell-list">
                  <!-- Populated by JavaScript -->
                </div>
              </div>

              <!-- Prepared Spells -->
              <div id="prepared-spells-card" class="tracker-card prepared-spells-card" style="display: none;">
                <div class="card-header collapsible-header" data-collapse="prepared">
                  <h2 class="card-title card-title--small">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                      <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path>
                      <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path>
                    </svg>
                    Prepared Spells
                    <span class="collapse-arrow">▼</span>
                  </h2>
                </div>
                <div id="prepared-spells-list" class="spell-list">
                  <!-- Populated by JavaScript -->
                </div>
              </div>
            </div>

            <!-- Features Section -->
            <div id="features-card" class="tracker-card features-card" style="display: none;">
              <div class="card-header">
                <h2 class="card-title">
                  <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <path d="M18 3a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3H6a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3V6a3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3h12a3 3 0 0 0 3-3 3 3 0 0 0-3-3z"></path>
                  </svg>
                  Class Features
                </h2>
              </div>
              <div id="features-grid" class="features-grid">
                <!-- Populated by JavaScript using safe DOM methods -->
              </div>
            </div>

            <!-- Rest Buttons -->
            <div class="rest-actions">
              <button id="short-rest-btn" class="rest-btn rest-btn--short">
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <circle cx="12" cy="12" r="10"></circle>
                  <polyline points="12 6 12 12 16 14"></polyline>
                </svg>
                Short Rest
              </button>
              <button id="long-rest-btn" class="rest-btn rest-btn--long">
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                </svg>
                Long Rest
              </button>
            </div>
          </div>
        </section>
      </>
    )}
  </div>
</BaseLayout>

<script define:vars={{ apiUrl, targetCharacter, slug, dndConditions }}>
  // Make data available to the module script
  window.__apiUrl = apiUrl;
  window.__targetCharacter = targetCharacter;
  window.__characterSlug = slug;
  window.__dndConditions = dndConditions;
</script>

<script>
  import {
    getAuthState,
    getLoginUrl,
    getLogoutUrl,
    isSsoAvailable,
    getAuthHeaders,
    type AuthState,
  } from '@lib/auth';

  // Get server-provided data
  const API_URL = (window as any).__apiUrl || '';
  const targetCharacter = (window as any).__targetCharacter;
  const characterSlug = (window as any).__characterSlug;

  // Don't run if no character found
  if (!targetCharacter) {
    // Character not found page is already shown
  } else {
    // Current state
    let currentCharacter = targetCharacter;
    let sessionState = {
      hp: 0,
      tempHp: 0,
      deathSaves: { successes: 0, failures: 0 },
      conditions: [] as string[],
      spellSlots: [] as { level: number; current: number }[],
      features: [] as { name: string; current: number }[],
      concentration: null as string | null,
    };
    let saveTimeout: number | null = null;
    let canEdit = false; // Whether the current user can edit this character

    // DOM Elements
    const authSection = document.getElementById('auth-section');
    const trackerSection = document.getElementById('tracker-section');
    const ssoBtn = document.getElementById('sso-btn');
    const ssoError = document.getElementById('sso-error');
    const ssoUnavailable = document.getElementById('sso-unavailable');
    const userGreeting = document.getElementById('user-greeting');
    const signOutBtn = document.getElementById('sign-out-btn');
    const accessDeniedMessage = document.getElementById('access-denied-message');
    const yourCharacterLink = document.getElementById('your-character-link') as HTMLAnchorElement;
    const trackerContent = document.getElementById('tracker-content');
    const saveStatus = document.getElementById('save-status');

    // Compact Dashboard Elements
    const acValue = document.getElementById('ac-value');
    const spellDcBlock = document.getElementById('spell-dc-block');
    const spellDcValue = document.getElementById('spell-dc-value');
    const profValue = document.getElementById('prof-value');
    const concentrationBlock = document.getElementById('concentration-block');
    const concentrationBtn = document.getElementById('concentration-btn');
    const concSpellName = document.getElementById('conc-spell-name');

    // HP Elements
    const currentHpInput = document.getElementById('current-hp') as HTMLInputElement;
    const maxHpSpan = document.getElementById('max-hp');
    const tempHpInput = document.getElementById('temp-hp') as HTMLInputElement;
    const hpBar = document.getElementById('hp-bar');
    const hpBarFill = document.getElementById('hp-bar-fill');

    // Spellcasting Elements
    const spellcastingSection = document.getElementById('spellcasting-section');
    const cantripsCard = document.getElementById('cantrips-card');
    const cantripsList = document.getElementById('cantrips-list');
    const preparedSpellsCard = document.getElementById('prepared-spells-card');
    const preparedSpellsList = document.getElementById('prepared-spells-list');
    const restSelect = document.getElementById('rest-select') as HTMLSelectElement;
    const spellSlotsGrid = document.getElementById('spell-slots-grid');

    // Death Saves Elements
    const deathSavesCard = document.getElementById('death-saves-card');
    const successPips = document.getElementById('success-pips');
    const failurePips = document.getElementById('failure-pips');
    const resetDeathSavesBtn = document.getElementById('reset-death-saves');

    // Conditions Elements
    const activeConditions = document.getElementById('active-conditions');
    const conditionBtns = document.querySelectorAll('.condition-btn');

    // Features
    const featuresCard = document.getElementById('features-card');
    const featuresGrid = document.getElementById('features-grid');

    // Rest Buttons
    const shortRestBtn = document.getElementById('short-rest-btn');
    const longRestBtn = document.getElementById('long-rest-btn');

    // ============================================
    // UI Updates (using safe DOM methods)
    // ============================================

    function updateSaveStatus(status: 'saving' | 'saved' | 'error') {
      if (!saveStatus) return;
      saveStatus.className = 'save-status save-status--' + status;
      const text = saveStatus.querySelector('.save-text');
      if (text) {
        text.textContent = status === 'saving' ? 'Saving...' : status === 'saved' ? 'Saved' : 'Error';
      }
    }

    function updateHpDisplay() {
      if (!currentCharacter) return;

      const hp = sessionState.hp;
      const maxHp = currentCharacter.maxHp;
      const tempHp = sessionState.tempHp;

      if (currentHpInput) currentHpInput.value = String(hp);
      if (maxHpSpan) maxHpSpan.textContent = String(maxHp);
      if (tempHpInput) tempHpInput.value = String(tempHp);

      // Update HP bar
      const percent = Math.min(100, Math.max(0, (hp / maxHp) * 100));
      if (hpBarFill) {
        hpBarFill.style.width = percent + '%';
      }
      if (hpBar) {
        hpBar.classList.remove('hp-bar--critical', 'hp-bar--warning', 'hp-bar--healthy', 'hp-bar--dead');
        if (hp <= 0) {
          hpBar.classList.add('hp-bar--dead');
        } else if (percent <= 25) {
          hpBar.classList.add('hp-bar--critical');
        } else if (percent <= 50) {
          hpBar.classList.add('hp-bar--warning');
        } else {
          hpBar.classList.add('hp-bar--healthy');
        }
      }

      // Show/hide death saves
      if (deathSavesCard) {
        deathSavesCard.style.display = hp <= 0 ? 'block' : 'none';
      }
    }

    function updateDeathSavesDisplay() {
      const { successes, failures } = sessionState.deathSaves;

      if (successPips) {
        successPips.querySelectorAll('.pip').forEach((pip, i) => {
          pip.classList.toggle('pip--filled', i < successes);
        });
      }
      if (failurePips) {
        failurePips.querySelectorAll('.pip').forEach((pip, i) => {
          pip.classList.toggle('pip--filled', i < failures);
        });
      }
    }

    function updateConditionsDisplay() {
      if (!activeConditions) return;

      // Clear existing content safely
      activeConditions.replaceChildren();

      if (sessionState.conditions.length === 0) {
        const noConditionsSpan = document.createElement('span');
        noConditionsSpan.className = 'no-conditions';
        noConditionsSpan.textContent = 'No active conditions';
        activeConditions.appendChild(noConditionsSpan);
      } else {
        sessionState.conditions.forEach(condition => {
          const tag = document.createElement('span');
          tag.className = 'condition-tag';
          tag.textContent = condition + ' ';

          const removeBtn = document.createElement('button');
          removeBtn.className = 'remove-condition';
          removeBtn.textContent = '×';
          removeBtn.addEventListener('click', () => toggleCondition(condition));

          tag.appendChild(removeBtn);
          activeConditions.appendChild(tag);
        });
      }

      // Update condition button states
      conditionBtns.forEach(btn => {
        const condition = (btn as HTMLElement).dataset.condition;
        btn.classList.toggle('condition-btn--active', sessionState.conditions.includes(condition || ''));
      });
    }

    function updateCombatDashboard() {
      if (!currentCharacter) return;

      // Update AC
      if (acValue) acValue.textContent = String(currentCharacter.ac);

      // Update Proficiency Bonus
      if (profValue) profValue.textContent = `+${currentCharacter.proficiencyBonus}`;

      // Update Spell DC (show if character has spellcasting)
      if (currentCharacter.spellcasting) {
        if (spellDcBlock) spellDcBlock.style.display = 'flex';
        if (spellDcValue) spellDcValue.textContent = String(currentCharacter.spellcasting.spellSaveDC);
        if (concentrationBlock) concentrationBlock.style.display = 'flex';
      } else {
        if (spellDcBlock) spellDcBlock.style.display = 'none';
        if (concentrationBlock) concentrationBlock.style.display = 'none';
      }

      updateConcentrationDisplay();
    }

    function updateConcentrationDisplay() {
      if (!concSpellName) return;

      if (sessionState.concentration) {
        concSpellName.textContent = sessionState.concentration;
        if (concentrationBtn) concentrationBtn.classList.add('conc-btn--active');
      } else {
        concSpellName.textContent = '—';
        if (concentrationBtn) concentrationBtn.classList.remove('conc-btn--active');
      }
    }

    function updateAbilityScoresDisplay() {
      if (!currentCharacter) return;

      const abilities = ['str', 'dex', 'con', 'int', 'wis', 'cha'] as const;
      abilities.forEach(ability => {
        const score = currentCharacter.abilityScores[ability];
        const mod = Math.floor((score - 10) / 2);
        const modStr = mod >= 0 ? `+${mod}` : String(mod);

        const modEl = document.getElementById(`${ability}-mod`);
        const scoreEl = document.getElementById(`${ability}-score`);
        if (modEl) modEl.textContent = modStr;
        if (scoreEl) scoreEl.textContent = String(score);
      });
    }

    function updateSpellListsDisplay() {
      if (!currentCharacter || !currentCharacter.spellcasting) {
        if (spellcastingSection) spellcastingSection.style.display = 'none';
        return;
      }

      if (spellcastingSection) spellcastingSection.style.display = 'block';

      // Cantrips
      const cantrips = currentCharacter.spellcasting.cantrips || [];
      if (cantrips.length > 0 && cantripsCard && cantripsList) {
        cantripsCard.style.display = 'block';
        cantripsList.replaceChildren();

        cantrips.forEach((spell: string) => {
          const spellEl = document.createElement('div');
          spellEl.className = 'spell-item spell-item--cantrip';
          spellEl.textContent = spell;
          cantripsList.appendChild(spellEl);
        });
      }

      // Prepared Spells
      const prepared = currentCharacter.spellcasting.preparedSpells || [];
      if (prepared.length > 0 && preparedSpellsCard && preparedSpellsList) {
        preparedSpellsCard.style.display = 'block';
        preparedSpellsList.replaceChildren();

        prepared.forEach((spell: string) => {
          const spellEl = document.createElement('button');
          spellEl.className = 'spell-item spell-item--prepared';
          if (sessionState.concentration === spell) {
            spellEl.classList.add('spell-item--concentrating');
          }

          const nameSpan = document.createElement('span');
          nameSpan.className = 'spell-name';
          nameSpan.textContent = spell;
          spellEl.appendChild(nameSpan);

          // Add concentration marker button (C icon)
          const concBtn = document.createElement('span');
          concBtn.className = 'spell-conc-marker';
          concBtn.textContent = 'C';
          concBtn.title = 'Set concentration';
          spellEl.appendChild(concBtn);

          spellEl.addEventListener('click', () => {
            if (!canEdit) return;
            // Toggle concentration on this spell
            if (sessionState.concentration === spell) {
              setConcentration(null);
            } else {
              setConcentration(spell);
            }
          });

          preparedSpellsList.appendChild(spellEl);
        });
      }
    }

    function setConcentration(spell: string | null) {
      if (!canEdit) return;
      sessionState.concentration = spell;
      updateConcentrationDisplay();
      updateSpellListsDisplay();
      scheduleSave();
    }

    function updateSpellSlotsDisplay() {
      if (!spellSlotsGrid || !currentCharacter) return;

      if (currentCharacter.spellSlots.length === 0) {
        return;
      }

      // Clear and rebuild using safe DOM methods
      spellSlotsGrid.replaceChildren();

      currentCharacter.spellSlots.forEach((slot: { level: number; max: number; current?: number }, slotIndex: number) => {
        const current = sessionState.spellSlots[slotIndex]?.current ?? slot.current ?? slot.max;

        const row = document.createElement('div');
        row.className = 'spell-slot-row';
        row.dataset.level = String(slot.level);

        const levelSpan = document.createElement('span');
        levelSpan.className = 'slot-level';
        levelSpan.textContent = `Level ${slot.level}`;
        row.appendChild(levelSpan);

        const pipsContainer = document.createElement('div');
        pipsContainer.className = 'slot-pips';

        for (let i = 0; i < slot.max; i++) {
          const pip = document.createElement('button');
          pip.className = 'slot-pip' + (i < current ? ' slot-pip--available' : '');
          pip.addEventListener('click', () => {
            if (canEdit) toggleSpellSlot(slotIndex, i);
          });
          pipsContainer.appendChild(pip);
        }

        row.appendChild(pipsContainer);
        spellSlotsGrid.appendChild(row);
      });
    }

    function updateFeaturesDisplay() {
      if (!featuresCard || !featuresGrid || !currentCharacter) return;

      if (currentCharacter.features.length === 0) {
        featuresCard.style.display = 'none';
        return;
      }

      featuresCard.style.display = 'block';

      // Clear and rebuild using safe DOM methods
      featuresGrid.replaceChildren();

      currentCharacter.features.forEach((feature: { name: string; max: number; current?: number; recharge: string }, featureIndex: number) => {
        const current = sessionState.features[featureIndex]?.current ?? feature.current ?? feature.max;

        const row = document.createElement('div');
        row.className = 'feature-row';

        const infoDiv = document.createElement('div');
        infoDiv.className = 'feature-info';

        const nameSpan = document.createElement('span');
        nameSpan.className = 'feature-name';
        nameSpan.textContent = feature.name;
        infoDiv.appendChild(nameSpan);

        const rechargeSpan = document.createElement('span');
        rechargeSpan.className = 'feature-recharge';
        rechargeSpan.textContent = feature.recharge;
        infoDiv.appendChild(rechargeSpan);

        row.appendChild(infoDiv);

        const pipsContainer = document.createElement('div');
        pipsContainer.className = 'feature-pips';

        for (let i = 0; i < feature.max; i++) {
          const pip = document.createElement('button');
          pip.className = 'feature-pip' + (i < current ? ' feature-pip--available' : '');
          pip.addEventListener('click', () => {
            if (canEdit) toggleFeature(featureIndex, i);
          });
          pipsContainer.appendChild(pip);
        }

        row.appendChild(pipsContainer);
        featuresGrid.appendChild(row);
      });
    }

    // ============================================
    // State Mutations
    // ============================================

    function setHp(newHp: number) {
      if (!currentCharacter || !canEdit) return;
      const previousHp = sessionState.hp;
      sessionState.hp = Math.max(0, Math.min(currentCharacter.maxHp, newHp));

      // Auto-clear concentration at 0 HP
      if (sessionState.hp <= 0 && previousHp > 0 && sessionState.concentration) {
        setConcentration(null);
      }

      // Show concentration check reminder when taking damage
      if (newHp < previousHp && sessionState.concentration && sessionState.hp > 0) {
        const damage = previousHp - sessionState.hp;
        const dcValue = Math.max(10, Math.floor(damage / 2));
        const conMod = Math.floor((currentCharacter.abilityScores.con - 10) / 2);
        const conModStr = conMod >= 0 ? `+${conMod}` : String(conMod);
        showConcentrationReminder(dcValue, conModStr);
      }

      updateHpDisplay();
      scheduleSave();
    }

    function showConcentrationReminder(dc: number, conMod: string) {
      // Create a brief toast notification using safe DOM methods
      const existing = document.querySelector('.conc-reminder');
      if (existing) existing.remove();

      const reminder = document.createElement('div');
      reminder.className = 'conc-reminder';

      const strong = document.createElement('strong');
      strong.textContent = 'Concentration Check!';
      reminder.appendChild(strong);

      const text = document.createTextNode(` DC ${dc} (CON save ${conMod})`);
      reminder.appendChild(text);

      document.body.appendChild(reminder);

      // Animate in
      setTimeout(() => reminder.classList.add('conc-reminder--visible'), 10);

      // Remove after 4 seconds
      setTimeout(() => {
        reminder.classList.remove('conc-reminder--visible');
        setTimeout(() => reminder.remove(), 300);
      }, 4000);
    }

    function setTempHp(newTempHp: number) {
      if (!canEdit) return;
      sessionState.tempHp = Math.max(0, newTempHp);
      scheduleSave();
    }

    function toggleDeathSave(type: 'success' | 'failure', index: number) {
      if (!canEdit) return;
      const key = type === 'success' ? 'successes' : 'failures';
      const current = sessionState.deathSaves[key];

      // If clicking on a filled pip, unfill it and all after
      // If clicking on an unfilled pip, fill up to it
      if (index < current) {
        sessionState.deathSaves[key] = index;
      } else {
        sessionState.deathSaves[key] = index + 1;
      }

      updateDeathSavesDisplay();
      scheduleSave();
    }

    function resetDeathSaves() {
      if (!canEdit) return;
      sessionState.deathSaves = { successes: 0, failures: 0 };
      updateDeathSavesDisplay();
      scheduleSave();
    }

    function toggleCondition(condition: string) {
      if (!canEdit) return;
      const index = sessionState.conditions.indexOf(condition);
      if (index >= 0) {
        sessionState.conditions.splice(index, 1);
      } else {
        sessionState.conditions.push(condition);
      }
      updateConditionsDisplay();
      scheduleSave();
    }

    function toggleSpellSlot(slotIndex: number, pipIndex: number) {
      if (!currentCharacter || !canEdit) return;
      const slot = currentCharacter.spellSlots[slotIndex];
      if (!slot) return;

      if (!sessionState.spellSlots[slotIndex]) {
        sessionState.spellSlots[slotIndex] = { level: slot.level, current: slot.max };
      }

      const current = sessionState.spellSlots[slotIndex].current;
      if (pipIndex < current) {
        sessionState.spellSlots[slotIndex].current = pipIndex;
      } else {
        sessionState.spellSlots[slotIndex].current = pipIndex + 1;
      }

      updateSpellSlotsDisplay();
      scheduleSave();
    }

    function toggleFeature(featureIndex: number, pipIndex: number) {
      if (!currentCharacter || !canEdit) return;
      const feature = currentCharacter.features[featureIndex];
      if (!feature) return;

      if (!sessionState.features[featureIndex]) {
        sessionState.features[featureIndex] = { name: feature.name, current: feature.max };
      }

      const current = sessionState.features[featureIndex].current;
      if (pipIndex < current) {
        sessionState.features[featureIndex].current = pipIndex;
      } else {
        sessionState.features[featureIndex].current = pipIndex + 1;
      }

      updateFeaturesDisplay();
      scheduleSave();
    }

    function handleShortRest() {
      if (!currentCharacter || !canEdit) return;

      // Restore short-rest features
      currentCharacter.features.forEach((feature: { name: string; recharge: string; max: number }, index: number) => {
        if (feature.recharge === 'short-rest') {
          if (!sessionState.features[index]) {
            sessionState.features[index] = { name: feature.name, current: feature.max };
          } else {
            sessionState.features[index].current = feature.max;
          }
        }
      });

      updateFeaturesDisplay();
      scheduleSave();
    }

    function handleLongRest() {
      if (!currentCharacter || !canEdit) return;

      // Restore HP to full
      sessionState.hp = currentCharacter.maxHp;
      sessionState.tempHp = 0;

      // Reset death saves
      sessionState.deathSaves = { successes: 0, failures: 0 };

      // Restore all spell slots
      currentCharacter.spellSlots.forEach((slot: { level: number; max: number }, index: number) => {
        sessionState.spellSlots[index] = { level: slot.level, current: slot.max };
      });

      // Restore all features
      currentCharacter.features.forEach((feature: { name: string; max: number }, index: number) => {
        sessionState.features[index] = { name: feature.name, current: feature.max };
      });

      // Clear conditions and concentration
      sessionState.conditions = [];
      sessionState.concentration = null;

      updateHpDisplay();
      updateDeathSavesDisplay();
      updateConditionsDisplay();
      updateSpellSlotsDisplay();
      updateFeaturesDisplay();
      updateConcentrationDisplay();
      updateSpellListsDisplay();
      scheduleSave();
    }

    function handleRestFromDropdown(restType: string) {
      if (restType === 'short') {
        handleShortRest();
      } else if (restType === 'long') {
        handleLongRest();
      }
      // Reset dropdown
      if (restSelect) restSelect.value = '';
    }

    // ============================================
    // API Interaction
    // ============================================

    function scheduleSave() {
      if (!canEdit) return;
      updateSaveStatus('saving');

      if (saveTimeout) {
        clearTimeout(saveTimeout);
      }

      saveTimeout = window.setTimeout(() => {
        saveSessionState();
      }, 300);
    }

    async function saveSessionState() {
      if (!currentCharacter || !API_URL || !canEdit) {
        updateSaveStatus('error');
        return;
      }

      try {
        const response = await fetch(`${API_URL}/player/drafts/${currentCharacter.slug}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
            ...getAuthHeaders(),
          },
          body: JSON.stringify({
            combat: {
              hp: sessionState.hp,
              tempHp: sessionState.tempHp,
            },
            deathSaves: sessionState.deathSaves,
            conditions: sessionState.conditions,
            spellSlots: sessionState.spellSlots,
            features: sessionState.features,
            concentration: sessionState.concentration,
          }),
        });

        if (response.ok) {
          updateSaveStatus('saved');
        } else {
          console.error('Failed to save session state:', response.status);
          updateSaveStatus('error');
        }
      } catch (error) {
        console.error('Error saving session state:', error);
        updateSaveStatus('error');
      }
    }

    async function loadSessionState() {
      if (!currentCharacter || !API_URL) return;

      try {
        const response = await fetch(`${API_URL}/player/drafts/${currentCharacter.slug}`, {
          headers: getAuthHeaders(),
        });

        if (response.ok) {
          const data = await response.json();
          if (data.sessionData) {
            sessionState = {
              hp: data.sessionData.combat?.hp ?? currentCharacter.currentHp,
              tempHp: data.sessionData.combat?.tempHp ?? 0,
              deathSaves: data.sessionData.deathSaves ?? { successes: 0, failures: 0 },
              conditions: data.sessionData.conditions ?? [],
              spellSlots: data.sessionData.spellSlots ?? [],
              features: data.sessionData.features ?? [],
              concentration: data.sessionData.concentration ?? null,
            };
          } else {
            // No saved state, use defaults
            initializeDefaultState();
          }

          updateHpDisplay();
          updateDeathSavesDisplay();
          updateConditionsDisplay();
          updateSpellSlotsDisplay();
          updateSpellListsDisplay();
          updateConcentrationDisplay();
          updateFeaturesDisplay();
        }
      } catch (error) {
        console.error('Error loading session state:', error);
        // Use defaults on error
        initializeDefaultState();
        updateHpDisplay();
        updateDeathSavesDisplay();
        updateConditionsDisplay();
        updateSpellSlotsDisplay();
        updateSpellListsDisplay();
        updateConcentrationDisplay();
        updateFeaturesDisplay();
      }
    }

    function initializeDefaultState() {
      if (!currentCharacter) return;
      sessionState = {
        hp: currentCharacter.currentHp,
        tempHp: 0,
        deathSaves: { successes: 0, failures: 0 },
        conditions: [],
        spellSlots: currentCharacter.spellSlots.map((s: { level: number; max: number; current?: number }) => ({ level: s.level, current: s.current ?? s.max })),
        features: currentCharacter.features.map((f: { name: string; max: number; current?: number }) => ({ name: f.name, current: f.current ?? f.max })),
        concentration: null,
      };
    }

    // ============================================
    // Authentication
    // ============================================

    function showAuthSection() {
      if (authSection) authSection.style.display = 'block';
      if (trackerSection) trackerSection.style.display = 'none';

      // Check if SSO is available
      if (!isSsoAvailable()) {
        if (ssoBtn) (ssoBtn as HTMLButtonElement).disabled = true;
        if (ssoUnavailable) ssoUnavailable.style.display = 'block';
      }
    }

    function showTrackerSection(auth: AuthState) {
      if (authSection) authSection.style.display = 'none';
      if (trackerSection) trackerSection.style.display = 'block';

      // Update greeting
      if (userGreeting && auth.email) {
        userGreeting.textContent = `Welcome, ${auth.email}`;
      }

      // Check if user can edit this character
      // User can edit if:
      // 1. Their assigned character matches the URL slug
      // 2. They are a DM
      const userCharacterSlug = auth.characterSlug;
      canEdit = auth.roles.isDm || userCharacterSlug === characterSlug;

      if (canEdit) {
        // User can edit - show tracker
        if (accessDeniedMessage) accessDeniedMessage.style.display = 'none';
        if (trackerContent) trackerContent.style.display = 'block';

        // Initialize state and UI
        initializeDefaultState();
        updateCombatDashboard();
        updateAbilityScoresDisplay();
        updateHpDisplay();
        updateDeathSavesDisplay();
        updateConditionsDisplay();
        updateSpellSlotsDisplay();
        updateSpellListsDisplay();
        updateFeaturesDisplay();

        // Load saved state from server
        loadSessionState();
      } else {
        // User cannot edit - show access denied
        if (accessDeniedMessage) accessDeniedMessage.style.display = 'block';
        if (trackerContent) trackerContent.style.display = 'none';

        // Set link to their character if they have one
        if (yourCharacterLink && userCharacterSlug) {
          yourCharacterLink.href = `/campaign/character/${userCharacterSlug}`;
          yourCharacterLink.textContent = 'Go to Your Character →';
        }
      }
    }

    function handleSsoClick() {
      const loginUrl = getLoginUrl(`/campaign/character/${characterSlug}`);
      if (loginUrl && loginUrl !== '#') {
        window.location.href = loginUrl;
      } else if (ssoError) {
        ssoError.textContent = 'Sign-in is not available. Please try again later.';
        ssoError.style.display = 'block';
      }
    }

    function handleSignOut() {
      const logoutUrl = getLogoutUrl(`/campaign/character/${characterSlug}`);
      window.location.href = logoutUrl;
    }

    // ============================================
    // Event Handlers
    // ============================================

    function setupEventHandlers() {
      // SSO button
      if (ssoBtn) {
        ssoBtn.addEventListener('click', handleSsoClick);
      }

      // Sign out button
      if (signOutBtn) {
        signOutBtn.addEventListener('click', handleSignOut);
      }

      // HP input
      if (currentHpInput) {
        currentHpInput.addEventListener('change', () => {
          setHp(parseInt(currentHpInput.value) || 0);
        });
      }

      // Temp HP input
      if (tempHpInput) {
        tempHpInput.addEventListener('change', () => {
          setTempHp(parseInt(tempHpInput.value) || 0);
        });
      }

      // HP quick action buttons
      document.querySelectorAll('.hp-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const delta = parseInt((btn as HTMLElement).dataset.delta || '0');
          setHp(sessionState.hp + delta);
        });
      });

      // Death save pips
      if (successPips) {
        successPips.querySelectorAll('.pip').forEach(pip => {
          pip.addEventListener('click', () => {
            const index = parseInt((pip as HTMLElement).dataset.index || '0');
            toggleDeathSave('success', index);
          });
        });
      }
      if (failurePips) {
        failurePips.querySelectorAll('.pip').forEach(pip => {
          pip.addEventListener('click', () => {
            const index = parseInt((pip as HTMLElement).dataset.index || '0');
            toggleDeathSave('failure', index);
          });
        });
      }

      // Reset death saves
      if (resetDeathSavesBtn) {
        resetDeathSavesBtn.addEventListener('click', resetDeathSaves);
      }

      // Condition buttons
      conditionBtns.forEach(btn => {
        btn.addEventListener('click', () => {
          const condition = (btn as HTMLElement).dataset.condition;
          if (condition) toggleCondition(condition);
        });
      });

      // Rest buttons (legacy)
      if (shortRestBtn) {
        shortRestBtn.addEventListener('click', handleShortRest);
      }
      if (longRestBtn) {
        longRestBtn.addEventListener('click', handleLongRest);
      }

      // Rest dropdown
      if (restSelect) {
        restSelect.addEventListener('change', () => {
          handleRestFromDropdown(restSelect.value);
        });
      }

      // Concentration button - click to clear
      if (concentrationBtn) {
        concentrationBtn.addEventListener('click', () => {
          if (sessionState.concentration && canEdit) {
            setConcentration(null);
          }
        });
      }

      // Collapsible headers
      document.querySelectorAll('.collapsible-header').forEach(header => {
        header.addEventListener('click', () => {
          const card = header.closest('.tracker-card');
          if (card) {
            card.classList.toggle('tracker-card--collapsed');
          }
        });
      });

      // Auth change listener
      window.addEventListener('auth-change', () => {
        const auth = getAuthState();
        if (auth && auth.method === 'cognito') {
          showTrackerSection(auth);
        } else {
          showAuthSection();
        }
      });
    }

    // ============================================
    // Initialize
    // ============================================

    function init() {
      const auth = getAuthState();
      if (auth && auth.method === 'cognito') {
        showTrackerSection(auth);
      } else {
        showAuthSection();
      }

      setupEventHandlers();
    }

    init();
  }
</script>

<style>
  .campaign-hub {
    max-width: 800px;
    margin: 0 auto;
    padding: var(--space-xl) var(--space-lg);
  }

  /* Not Found Section */
  .not-found-section {
    padding: var(--space-2xl) 0;
  }

  .not-found-container {
    text-align: center;
    padding: var(--space-2xl);
    background: var(--color-bg-secondary);
    border: 2px solid var(--color-border);
    border-radius: var(--radius-lg);
  }

  .not-found-icon {
    color: var(--color-text-muted);
    margin-bottom: var(--space-md);
  }

  .not-found-container h1 {
    color: var(--color-gold);
    font-family: var(--font-display);
    margin: 0 0 var(--space-sm);
  }

  .not-found-container p {
    color: var(--color-text-secondary);
    margin: 0 0 var(--space-lg);
  }

  .back-link {
    color: var(--color-gold);
    text-decoration: none;
  }

  .back-link:hover {
    text-decoration: underline;
  }

  /* Auth Section */
  .auth-section {
    margin-bottom: var(--space-2xl);
  }

  .auth-container {
    background: var(--color-bg-secondary);
    border: 2px solid var(--color-gold);
    border-radius: var(--radius-lg);
    padding: var(--space-2xl);
    max-width: 500px;
    margin: 0 auto;
  }

  .auth-header {
    text-align: center;
    margin-bottom: var(--space-xl);
  }

  .auth-icon {
    color: var(--color-gold);
    margin-bottom: var(--space-md);
  }

  .auth-title {
    font-family: var(--font-display);
    font-size: var(--text-3xl);
    color: var(--color-gold);
    margin: 0 0 var(--space-sm);
  }

  .auth-subtitle {
    color: var(--color-text-secondary);
    margin: 0;
  }

  .auth-methods {
    display: flex;
    flex-direction: column;
    gap: var(--space-lg);
  }

  .auth-method {
    text-align: center;
  }

  .method-description {
    font-size: var(--text-sm);
    color: var(--color-text-muted);
    margin: 0 0 var(--space-md);
  }

  .auth-error {
    color: var(--color-accent);
    background: rgba(192, 86, 86, 0.1);
    padding: var(--space-sm) var(--space-md);
    border-radius: var(--radius-md);
    font-size: var(--text-sm);
    margin-top: var(--space-md);
  }

  .auth-notice {
    color: var(--color-text-muted);
    font-size: var(--text-sm);
    margin-top: var(--space-md);
    font-style: italic;
  }

  .sso-btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: var(--space-sm);
    width: 100%;
    padding: var(--space-md) var(--space-lg);
    background: var(--color-gold);
    border: none;
    border-radius: var(--radius-md);
    color: var(--color-bg);
    font-size: var(--text-base);
    font-weight: 600;
    cursor: pointer;
    transition: all var(--transition-fast);
  }

  .sso-btn:hover:not(:disabled) {
    background: var(--color-gold-light);
    transform: translateY(-1px);
  }

  .sso-btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
  }

  /* Tracker Section */
  .tracker-section {
    padding-bottom: var(--space-2xl);
  }

  .tracker-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--space-xl);
    padding-bottom: var(--space-md);
    border-bottom: 2px solid var(--color-gold);
  }

  .tracker-title {
    font-family: var(--font-display);
    font-size: var(--text-2xl);
    color: var(--color-gold);
    margin: 0;
  }

  .tracker-subtitle {
    color: var(--color-text-secondary);
    font-size: var(--text-sm);
    margin: var(--space-xs) 0 0;
  }

  .header-actions {
    display: flex;
    align-items: center;
    gap: var(--space-md);
  }

  .save-status {
    display: flex;
    align-items: center;
    gap: var(--space-xs);
    font-size: var(--text-sm);
    color: var(--color-text-muted);
  }

  .save-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: var(--color-success, #4CAF50);
  }

  .save-status--saving .save-dot {
    background: var(--color-gold);
    animation: pulse 1s infinite;
  }

  .save-status--error .save-dot {
    background: var(--color-accent);
  }

  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
  }

  .sign-out-btn {
    padding: var(--space-xs) var(--space-md);
    background: transparent;
    border: 1px solid var(--color-border);
    border-radius: var(--radius-md);
    color: var(--color-text-muted);
    font-size: var(--text-sm);
    cursor: pointer;
    transition: all var(--transition-fast);
  }

  .sign-out-btn:hover {
    border-color: var(--color-accent);
    color: var(--color-accent);
  }

  /* Access Denied Message */
  .access-denied-message {
    text-align: center;
    padding: var(--space-2xl);
    background: var(--color-bg-secondary);
    border-radius: var(--radius-lg);
    border: 1px solid var(--color-border);
  }

  .access-denied-message .message-icon {
    color: var(--color-text-muted);
    margin-bottom: var(--space-md);
  }

  .access-denied-message h2 {
    color: var(--color-gold);
    margin: 0 0 var(--space-sm);
  }

  .access-denied-message p {
    color: var(--color-text-secondary);
    margin: 0 0 var(--space-lg);
  }

  .party-link {
    color: var(--color-gold);
    text-decoration: none;
  }

  .party-link:hover {
    text-decoration: underline;
  }

  /* Tracker Cards */
  .tracker-content {
    display: flex;
    flex-direction: column;
    gap: var(--space-lg);
  }

  .tracker-card {
    background: var(--color-bg-secondary);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-lg);
    padding: var(--space-lg);
  }

  .card-header {
    margin-bottom: var(--space-md);
  }

  .card-title {
    display: flex;
    align-items: center;
    gap: var(--space-sm);
    font-family: var(--font-display);
    font-size: var(--text-lg);
    color: var(--color-gold);
    margin: 0;
  }

  .card-title--small {
    font-size: var(--text-base);
  }

  .card-header--with-action {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  /* Collapsible Cards */
  .collapsible-header {
    cursor: pointer;
    user-select: none;
  }

  .collapse-arrow {
    margin-left: auto;
    font-size: var(--text-xs);
    transition: transform var(--transition-fast);
  }

  .tracker-card--collapsed .collapse-arrow {
    transform: rotate(-90deg);
  }

  .tracker-card--collapsed .spell-list,
  .tracker-card--collapsed .conditions-grid,
  .tracker-card--collapsed .death-saves-grid,
  .tracker-card--collapsed .active-conditions {
    display: none;
  }

  /* Combat Dashboard */
  .combat-dashboard {
    display: flex;
    gap: var(--space-md);
    padding: var(--space-md);
    background: var(--color-bg-secondary);
    border: 2px solid var(--color-gold);
    border-radius: var(--radius-lg);
    margin-bottom: var(--space-md);
  }

  .stat-block {
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: var(--space-sm) var(--space-md);
    background: var(--color-bg);
    border-radius: var(--radius-md);
    min-width: 60px;
  }

  .stat-block--hp {
    flex: 1;
    min-width: 120px;
  }

  .stat-label {
    font-size: var(--text-xs);
    color: var(--color-text-muted);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-bottom: var(--space-xs);
  }

  .stat-value {
    font-size: var(--text-xl);
    font-weight: 700;
    color: var(--color-gold);
  }

  .hp-inline {
    display: flex;
    align-items: baseline;
    gap: 4px;
  }

  .hp-input-compact {
    width: 50px;
    padding: 2px 4px;
    background: transparent;
    border: none;
    border-bottom: 2px solid var(--color-gold);
    color: var(--color-text);
    font-size: var(--text-xl);
    font-weight: 700;
    text-align: center;
  }

  .hp-input-compact:focus {
    outline: none;
    border-color: var(--color-accent);
  }

  .hp-sep {
    color: var(--color-text-muted);
  }

  .hp-max-compact {
    font-size: var(--text-lg);
    color: var(--color-text-secondary);
  }

  .hp-bar-mini {
    width: 100%;
    height: 6px;
    background: var(--color-bg-tertiary);
    border-radius: var(--radius-full);
    overflow: hidden;
    margin-top: var(--space-xs);
  }

  .hp-bar-fill-mini {
    height: 100%;
    background: var(--color-success, #4CAF50);
    transition: width var(--transition-fast);
  }

  .hp-bar-mini.hp-bar--warning .hp-bar-fill-mini {
    background: var(--color-gold);
  }

  .hp-bar-mini.hp-bar--critical .hp-bar-fill-mini {
    background: var(--color-accent);
  }

  .hp-bar-mini.hp-bar--dead .hp-bar-fill-mini {
    background: #333;
  }

  /* Concentration */
  .conc-btn {
    padding: var(--space-xs) var(--space-sm);
    background: var(--color-bg-tertiary);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-md);
    color: var(--color-text-muted);
    font-size: var(--text-sm);
    cursor: pointer;
    transition: all var(--transition-fast);
    max-width: 100px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .conc-btn--active {
    background: var(--color-accent);
    border-color: var(--color-accent);
    color: white;
  }

  .conc-spell {
    font-size: var(--text-xs);
  }

  /* HP Actions Row */
  .hp-actions-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: var(--space-sm) var(--space-md);
    background: var(--color-bg-secondary);
    border-radius: var(--radius-md);
    margin-bottom: var(--space-md);
  }

  .temp-label {
    color: var(--color-text-muted);
    font-size: var(--text-sm);
  }

  /* Ability Scores Row */
  .abilities-row {
    display: flex;
    justify-content: space-between;
    gap: var(--space-sm);
    padding: var(--space-md);
    background: var(--color-bg-secondary);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-lg);
    margin-bottom: var(--space-lg);
  }

  .ability {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: var(--space-sm);
    background: var(--color-bg);
    border-radius: var(--radius-md);
  }

  .ability-name {
    font-size: var(--text-xs);
    font-weight: 600;
    color: var(--color-gold);
    text-transform: uppercase;
    letter-spacing: 0.1em;
  }

  .ability-mod {
    font-size: var(--text-xl);
    font-weight: 700;
    color: var(--color-text);
  }

  .ability-score {
    font-size: var(--text-xs);
    color: var(--color-text-muted);
  }

  /* Rest Dropdown */
  .rest-select {
    padding: var(--space-xs) var(--space-sm);
    background: var(--color-bg);
    border: 1px solid var(--color-gold);
    border-radius: var(--radius-md);
    color: var(--color-gold);
    font-size: var(--text-sm);
    cursor: pointer;
  }

  .rest-select:hover {
    background: var(--color-gold);
    color: var(--color-bg);
  }

  /* Spell Lists */
  .spellcasting-section {
    display: flex;
    flex-direction: column;
    gap: var(--space-md);
  }

  .spell-list {
    display: flex;
    flex-wrap: wrap;
    gap: var(--space-sm);
  }

  .spell-item {
    padding: var(--space-xs) var(--space-sm);
    background: var(--color-bg);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-md);
    font-size: var(--text-sm);
    color: var(--color-text);
  }

  .spell-item--cantrip {
    border-color: var(--color-gold);
    color: var(--color-gold);
  }

  .spell-item--prepared {
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: var(--space-xs);
    transition: all var(--transition-fast);
  }

  .spell-item--prepared:hover {
    border-color: var(--color-accent);
  }

  .spell-conc-marker {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 16px;
    height: 16px;
    background: var(--color-bg-tertiary);
    border-radius: 50%;
    font-size: 10px;
    font-weight: 600;
    color: var(--color-text-muted);
    opacity: 0.5;
  }

  .spell-item--prepared:hover .spell-conc-marker {
    opacity: 1;
    background: var(--color-accent);
    color: white;
  }

  .spell-item--concentrating {
    background: var(--color-accent);
    border-color: var(--color-accent);
    color: white;
  }

  .spell-item--concentrating .spell-conc-marker {
    opacity: 1;
    background: white;
    color: var(--color-accent);
  }

  /* Concentration Reminder Toast */
  .conc-reminder {
    position: fixed;
    top: 80px;
    left: 50%;
    transform: translateX(-50%) translateY(-20px);
    padding: var(--space-md) var(--space-lg);
    background: var(--color-accent);
    color: white;
    border-radius: var(--radius-lg);
    box-shadow: var(--shadow-lg);
    font-size: var(--text-base);
    z-index: 1000;
    opacity: 0;
    transition: opacity var(--transition-fast), transform var(--transition-fast);
  }

  .conc-reminder--visible {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
  }

  /* HP Controls */
  .temp-hp {
    display: flex;
    align-items: center;
    gap: var(--space-sm);
    font-size: var(--text-sm);
    color: var(--color-text-muted);
  }

  .temp-hp-input {
    width: 60px;
    padding: var(--space-xs) var(--space-sm);
    background: var(--color-bg);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-md);
    color: var(--color-text);
    font-size: var(--text-sm);
    text-align: center;
  }

  .hp-quick-actions {
    display: flex;
    gap: var(--space-xs);
  }

  .hp-btn {
    padding: var(--space-xs) var(--space-sm);
    border: none;
    border-radius: var(--radius-md);
    font-weight: 600;
    cursor: pointer;
    transition: all var(--transition-fast);
  }

  .hp-btn--damage {
    background: var(--color-accent);
    color: white;
  }

  .hp-btn--heal {
    background: var(--color-success, #4CAF50);
    color: white;
  }

  .hp-btn:hover {
    transform: translateY(-1px);
    opacity: 0.9;
  }

  /* Death Saves */
  .death-saves-card {
    border-color: var(--color-accent);
  }

  .death-title {
    color: var(--color-accent);
  }

  .death-saves-grid {
    display: flex;
    flex-direction: column;
    gap: var(--space-md);
    margin-bottom: var(--space-md);
  }

  .death-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
  }

  .death-label {
    font-size: var(--text-sm);
    color: var(--color-text-secondary);
  }

  .death-pips {
    display: flex;
    gap: var(--space-sm);
  }

  .death-pips .pip {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    border: 2px solid var(--color-success, #4CAF50);
    background: transparent;
    cursor: pointer;
    transition: all var(--transition-fast);
  }

  .death-pips .pip:hover {
    transform: scale(1.1);
  }

  .death-pips .pip--filled {
    background: var(--color-success, #4CAF50);
  }

  .death-pips--failure .pip {
    border-color: var(--color-accent);
  }

  .death-pips--failure .pip--filled {
    background: var(--color-accent);
  }

  .reset-death-saves {
    width: 100%;
    padding: var(--space-sm);
    background: transparent;
    border: 1px solid var(--color-border);
    border-radius: var(--radius-md);
    color: var(--color-text-muted);
    font-size: var(--text-sm);
    cursor: pointer;
    transition: all var(--transition-fast);
  }

  .reset-death-saves:hover {
    border-color: var(--color-gold);
    color: var(--color-gold);
  }

  /* Conditions */
  .active-conditions {
    display: flex;
    flex-wrap: wrap;
    gap: var(--space-sm);
    margin-bottom: var(--space-md);
    min-height: 32px;
  }

  .no-conditions {
    color: var(--color-text-muted);
    font-size: var(--text-sm);
    font-style: italic;
  }

  .condition-tag {
    display: inline-flex;
    align-items: center;
    gap: var(--space-xs);
    padding: var(--space-xs) var(--space-sm);
    background: var(--color-accent);
    color: white;
    border-radius: var(--radius-md);
    font-size: var(--text-sm);
  }

  .remove-condition {
    background: transparent;
    border: none;
    color: white;
    cursor: pointer;
    font-size: var(--text-base);
    line-height: 1;
    padding: 0;
    margin-left: var(--space-xs);
  }

  .conditions-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
    gap: var(--space-sm);
  }

  .condition-btn {
    padding: var(--space-xs) var(--space-sm);
    background: var(--color-bg);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-md);
    color: var(--color-text-secondary);
    font-size: var(--text-xs);
    cursor: pointer;
    transition: all var(--transition-fast);
  }

  .condition-btn:hover {
    border-color: var(--color-gold);
    color: var(--color-gold);
  }

  .condition-btn--active {
    background: var(--color-accent);
    border-color: var(--color-accent);
    color: white;
  }

  /* Spell Slots */
  .spell-slots-grid {
    display: flex;
    flex-direction: column;
    gap: var(--space-md);
  }

  .spell-slot-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
  }

  .slot-level {
    font-size: var(--text-sm);
    color: var(--color-text-secondary);
    min-width: 60px;
  }

  .slot-pips {
    display: flex;
    gap: var(--space-xs);
  }

  .slot-pip {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    border: 2px solid var(--color-gold);
    background: transparent;
    cursor: pointer;
    transition: all var(--transition-fast);
  }

  .slot-pip:hover {
    transform: scale(1.1);
  }

  .slot-pip--available {
    background: var(--color-gold);
  }

  /* Features */
  .features-grid {
    display: flex;
    flex-direction: column;
    gap: var(--space-md);
  }

  .feature-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
  }

  .feature-info {
    display: flex;
    flex-direction: column;
  }

  .feature-name {
    font-size: var(--text-sm);
    color: var(--color-text);
  }

  .feature-recharge {
    font-size: var(--text-xs);
    color: var(--color-text-muted);
  }

  .feature-pips {
    display: flex;
    gap: var(--space-xs);
  }

  .feature-pip {
    width: 18px;
    height: 18px;
    border-radius: 50%;
    border: 2px solid var(--color-accent);
    background: transparent;
    cursor: pointer;
    transition: all var(--transition-fast);
  }

  .feature-pip:hover {
    transform: scale(1.1);
  }

  .feature-pip--available {
    background: var(--color-accent);
  }

  /* Rest Actions */
  .rest-actions {
    display: flex;
    gap: var(--space-md);
    margin-top: var(--space-lg);
  }

  .rest-btn {
    flex: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--space-sm);
    padding: var(--space-md);
    border: none;
    border-radius: var(--radius-md);
    font-size: var(--text-base);
    font-weight: 600;
    cursor: pointer;
    transition: all var(--transition-fast);
  }

  .rest-btn--short {
    background: var(--color-bg-secondary);
    border: 1px solid var(--color-gold);
    color: var(--color-gold);
  }

  .rest-btn--short:hover {
    background: var(--color-gold);
    color: var(--color-bg);
  }

  .rest-btn--long {
    background: var(--color-gold);
    color: var(--color-bg);
  }

  .rest-btn--long:hover {
    background: var(--color-gold-light);
  }

  /* Mobile Responsive */
  @media (max-width: 640px) {
    .tracker-header {
      flex-direction: column;
      align-items: flex-start;
      gap: var(--space-md);
    }

    .header-actions {
      width: 100%;
      justify-content: space-between;
    }

    .combat-dashboard {
      flex-wrap: wrap;
      gap: var(--space-sm);
    }

    .stat-block {
      min-width: 50px;
      padding: var(--space-xs) var(--space-sm);
    }

    .stat-block--hp {
      flex-basis: 100%;
      min-width: unset;
    }

    .stat-block--conc {
      flex-basis: 100%;
    }

    .hp-actions-row {
      flex-direction: column;
      gap: var(--space-sm);
    }

    .abilities-row {
      flex-wrap: wrap;
      gap: var(--space-xs);
    }

    .ability {
      flex-basis: calc(33.33% - var(--space-xs));
      min-width: 0;
      padding: var(--space-xs);
    }

    .ability-mod {
      font-size: var(--text-lg);
    }

    .conditions-grid {
      grid-template-columns: repeat(3, 1fr);
    }

    .spell-list {
      gap: var(--space-xs);
    }

    .spell-item {
      font-size: var(--text-xs);
    }

    .rest-actions {
      flex-direction: column;
    }
  }
</style>
