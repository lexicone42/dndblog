---
/**
 * DM Notes Page
 *
 * A private markdown editor for DM session notes with AI review capabilities.
 * Features:
 * - Editor tab: EasyMDE markdown editor with autosave and AI review
 * - Browser tab: View, search, and manage uploaded notes
 * - Offline support: Cached notes viewable when offline
 *
 * Components are extracted into /components/dm-notes/ for maintainability.
 */
import BaseLayout from '@layouts/BaseLayout.astro';
import AccessDenied from '@components/dm-notes/AccessDenied.astro';
import TabNavigation from '@components/dm-notes/TabNavigation.astro';
import DMNotesEditor from '@components/dm-notes/DMNotesEditor.astro';
import DMNotesBrowser from '@components/dm-notes/DMNotesBrowser.astro';
import DMNotesGenerator from '@components/dm-notes/DMNotesGenerator.astro';
import ViewNoteModal from '@components/dm-notes/ViewNoteModal.astro';
import DeleteConfirmModal from '@components/dm-notes/DeleteConfirmModal.astro';
import '@components/dm-notes/dm-notes-shared.css';

// Get API URL from environment variable
const apiUrl = import.meta.env.PUBLIC_DM_NOTES_API_URL || '';
---

<BaseLayout
  title="DM Notes - Rudiger's Evocation of Events"
  description="Private DM session notes editor"
>
  <!-- Load EasyMDE CSS and highlight.js for code syntax in head via fragment -->
  <Fragment slot="head">
    <link rel="stylesheet" href="https://unpkg.com/easymde@2.18.0/dist/easymde.min.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" />
  </Fragment>

  <div class="dm-notes">
    <AccessDenied />
    <TabNavigation />
    <DMNotesEditor />
    <DMNotesBrowser />
    <DMNotesGenerator />
    <ViewNoteModal />
    <DeleteConfirmModal />
  </div>

  <!-- Store API URL in a data attribute -->
  <div id="config" data-api-url={apiUrl} style="display: none;"></div>

  <!-- Load EasyMDE and Turndown (for HTML-to-Markdown paste) from CDN -->
  <script is:inline src="https://unpkg.com/easymde@2.18.0/dist/easymde.min.js"></script>
  <script is:inline src="https://unpkg.com/turndown@7.1.2/dist/turndown.js"></script>
  <!-- Markdown rendering with syntax highlighting and XSS protection -->
  <script is:inline src="https://cdnjs.cloudflare.com/ajax/libs/marked/12.0.0/marked.min.js"></script>
  <script is:inline src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script is:inline src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.8/purify.min.js"></script>

  <!-- Editor Script -->
  <script is:inline>
    (function() {
      var STORAGE_KEY = 'dm-notes-draft';
      var TITLE_KEY = 'dm-notes-title';
      var editor = null;
      var saveTimeout = null;
      var turndownService = null;

      function getToken() {
        var params = new URLSearchParams(window.location.search);
        return params.get('token');
      }

      function getApiUrl() {
        var configEl = document.getElementById('config');
        return configEl ? configEl.dataset.apiUrl : '';
      }

      function showEditor() {
        document.getElementById('access-denied').style.display = 'none';
        document.getElementById('editor-container').style.display = 'block';
      }

      function showAccessDenied() {
        document.getElementById('access-denied').style.display = 'flex';
        document.getElementById('editor-container').style.display = 'none';
      }

      function updateSaveStatus(status, isError) {
        var el = document.getElementById('save-status');
        el.textContent = status;
        if (isError) {
          el.classList.add('save-status--error');
          el.classList.remove('save-status--success');
        } else if (status.includes('Saved')) {
          el.classList.add('save-status--success');
          el.classList.remove('save-status--error');
        } else {
          el.classList.remove('save-status--error');
          el.classList.remove('save-status--success');
        }
      }

      function saveDraft() {
        if (!editor) return;
        var content = editor.value();
        var title = document.getElementById('session-title').value;
        localStorage.setItem(STORAGE_KEY, content);
        localStorage.setItem(TITLE_KEY, title);
        updateSaveStatus('Saved locally');
      }

      function loadDraft() {
        var savedContent = localStorage.getItem(STORAGE_KEY);
        var savedTitle = localStorage.getItem(TITLE_KEY);
        if (savedContent && editor) {
          editor.value(savedContent);
        }
        if (savedTitle) {
          document.getElementById('session-title').value = savedTitle;
        }
      }

      function debounceSave() {
        clearTimeout(saveTimeout);
        updateSaveStatus('Saving...');
        saveTimeout = setTimeout(saveDraft, 1000);
      }

      function convertHtmlToMarkdown(html) {
        if (!turndownService) {
          turndownService = new window.TurndownService({
            headingStyle: 'atx',
            codeBlockStyle: 'fenced'
          });
        }
        return turndownService.turndown(html);
      }

      function handlePaste(cm, event) {
        var clipboardData = event.clipboardData || window.clipboardData;
        if (!clipboardData) return;

        var html = clipboardData.getData('text/html');
        var plainText = clipboardData.getData('text/plain');

        if (html && html.trim() && plainText && plainText.trim()) {
          var tempDiv = document.createElement('div');
          tempDiv.innerHTML = html;
          var hasFormatting = tempDiv.querySelector('p, br, div, h1, h2, h3, h4, h5, h6, ul, ol, li, table, a, strong, em, b, i, code, pre, blockquote');

          if (hasFormatting) {
            event.preventDefault();
            var markdown = convertHtmlToMarkdown(html);
            var doc = cm.getDoc();
            var cursor = doc.getCursor();
            doc.replaceRange(markdown, cursor);
          }
        }
      }

      function showResult(message, isSuccess) {
        var resultEl = document.getElementById('publish-result');
        resultEl.textContent = message;
        resultEl.style.display = 'block';
        resultEl.classList.toggle('publish-result--success', isSuccess);
        resultEl.classList.toggle('publish-result--error', !isSuccess);

        if (isSuccess) {
          setTimeout(function() {
            resultEl.style.display = 'none';
          }, 5000);
        }
      }

      function buildFrontmatter(title, isDraft) {
        var now = new Date().toISOString();
        var status = isDraft ? 'draft' : 'published';
        return '---\n' +
          'title: "' + title.replace(/"/g, '\\"') + '"\n' +
          'date: ' + now + '\n' +
          'status: ' + status + '\n' +
          '---\n\n';
      }

      async function publishNote(isDraft) {
        var token = getToken();
        var apiUrl = getApiUrl();

        if (!token || !apiUrl) {
          showResult('Missing token or API configuration', false);
          return;
        }

        var publishBtn = document.getElementById('publish-btn');
        publishBtn.disabled = true;
        publishBtn.textContent = 'Publishing...';

        try {
          var title = document.getElementById('session-title').value || 'Untitled Session';
          var content = editor.value();
          var fullContent = buildFrontmatter(title, isDraft) + content;

          var filename = title
            .toLowerCase()
            .replace(/[^a-z0-9]+/g, '-')
            .replace(/^-|-$/g, '');
          filename = new Date().toISOString().split('T')[0] + '-' + filename + '.md';

          var urlResponse = await fetch(apiUrl + '/upload-url?filename=' + encodeURIComponent(filename), {
            method: 'GET',
            headers: {
              'X-DM-Token': token
            }
          });

          if (!urlResponse.ok) {
            var errorText = await urlResponse.text();
            throw new Error('Failed to get upload URL: ' + errorText);
          }

          var urlData = await urlResponse.json();
          var uploadUrl = urlData.uploadUrl;

          var uploadResponse = await fetch(uploadUrl, {
            method: 'PUT',
            body: fullContent,
            headers: {
              'Content-Type': 'text/markdown'
            }
          });

          if (!uploadResponse.ok) {
            throw new Error('Failed to upload note');
          }

          localStorage.removeItem(STORAGE_KEY);
          localStorage.removeItem(TITLE_KEY);
          editor.value('');
          document.getElementById('session-title').value = '';

          showResult('Note published successfully! Filename: ' + filename, true);
          updateSaveStatus('Published');

        } catch (error) {
          showResult('Error: ' + error.message, false);
        } finally {
          publishBtn.disabled = false;
          publishBtn.textContent = 'Save';
        }
      }

      async function requestReview() {
        var token = getToken();
        var apiUrl = getApiUrl();

        if (!token || !apiUrl) {
          showResult('Missing token or API configuration', false);
          return;
        }

        var reviewBtn = document.getElementById('review-btn');
        var resultContainer = document.getElementById('review-result');
        var scoreEl = document.getElementById('review-score');
        var statusEl = document.getElementById('review-status');
        var summaryEl = document.getElementById('review-summary');
        var suggestionsEl = document.getElementById('review-suggestions');

        reviewBtn.disabled = true;
        reviewBtn.textContent = 'Reviewing...';
        resultContainer.style.display = 'none';

        try {
          var content = editor.value();

          if (!content.trim()) {
            showResult('Please write some content before requesting a review', false);
            return;
          }

          var response = await fetch(apiUrl + '/review', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'X-DM-Token': token
            },
            body: JSON.stringify({ content: content })
          });

          if (!response.ok) {
            var errorData = await response.json().catch(function() { return {}; });
            throw new Error(errorData.error || 'Review request failed');
          }

          var reviewData = await response.json();

          scoreEl.textContent = reviewData.score;
          statusEl.textContent = reviewData.publishReady ? '✓ Ready to Publish' : '⚠ Needs Work';
          statusEl.className = 'review-result__status ' +
            (reviewData.publishReady ? 'review-result__status--ready' : 'review-result__status--needs-work');

          summaryEl.textContent = reviewData.summary;

          suggestionsEl.innerHTML = '';
          if (reviewData.suggestions && reviewData.suggestions.length > 0) {
            reviewData.suggestions.forEach(function(suggestion) {
              var li = document.createElement('li');
              li.textContent = suggestion;
              suggestionsEl.appendChild(li);
            });
          }

          resultContainer.style.display = 'block';

        } catch (error) {
          showResult('Review Error: ' + error.message, false);
        } finally {
          reviewBtn.disabled = false;
          reviewBtn.textContent = 'AI Review';
        }
      }

      function initEditor() {
        var token = getToken();
        if (!token) {
          showAccessDenied();
          return;
        }

        showEditor();
        document.getElementById('tab-navigation').style.display = 'flex';

        var textarea = document.getElementById('markdown-editor');
        editor = new window.EasyMDE({
          element: textarea,
          autofocus: true,
          spellChecker: false,
          placeholder: 'Write your session notes here...\n\n## What Happened\n\n## Key NPCs\n\n## Plot Hooks\n\n## Notes for Next Session',
          toolbar: [
            'bold', 'italic', 'heading', '|',
            'quote', 'unordered-list', 'ordered-list', '|',
            'link', 'image', '|',
            'preview', 'side-by-side', 'fullscreen', '|',
            'guide'
          ],
          status: ['lines', 'words', 'cursor'],
          renderingConfig: {
            singleLineBreaks: false,
            codeSyntaxHighlighting: true
          }
        });

        editor.codemirror.on('change', debounceSave);
        editor.codemirror.on('paste', handlePaste);
        document.getElementById('session-title').addEventListener('input', debounceSave);

        loadDraft();

        document.getElementById('publish-btn').addEventListener('click', function() {
          publishNote(false);
        });

        document.getElementById('review-btn').addEventListener('click', requestReview);

        // Template insertion
        initTemplateSelector();
      }

      function initTemplateSelector() {
        var templatesData = document.getElementById('templates-data');
        var templates = [];

        try {
          templates = JSON.parse(templatesData.textContent || '[]');
        } catch (e) {
          console.warn('Failed to parse templates:', e);
          return;
        }

        var selectEl = document.getElementById('template-select');
        var insertBtn = document.getElementById('insert-template-btn');

        if (!selectEl || !insertBtn) return;

        insertBtn.addEventListener('click', function() {
          var templateId = selectEl.value;
          if (!templateId) {
            alert('Please select a template first');
            return;
          }

          var template = templates.find(function(t) { return t.id === templateId; });
          if (!template) return;

          var currentContent = editor.value();
          var hasContent = currentContent.trim().length > 0;

          if (hasContent) {
            var confirmInsert = confirm(
              'Insert "' + template.name + '" template?\n\n' +
              'This will add the template at the cursor position.\n' +
              'Your existing content will be preserved.'
            );
            if (!confirmInsert) return;

            // Insert at cursor position
            var cm = editor.codemirror;
            var cursor = cm.getCursor();
            cm.replaceRange('\n\n' + template.content, cursor);
          } else {
            // Empty editor - replace with template
            editor.value(template.content);
          }

          // Reset selector
          selectEl.value = '';
          debounceSave();
        });

        // Also allow double-click on select to insert
        selectEl.addEventListener('dblclick', function() {
          if (selectEl.value) {
            insertBtn.click();
          }
        });
      }

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initEditor);
      } else {
        initEditor();
      }
    })();
  </script>

  <!-- Browser Script -->
  <script is:inline>
    (function() {
      var NOTES_CACHE_KEY = 'dm-notes-cache';
      var allNotes = [];
      var currentNoteKey = null;

      function getToken() {
        var params = new URLSearchParams(window.location.search);
        return params.get('token');
      }

      function getApiUrl() {
        var configEl = document.getElementById('config');
        return configEl ? configEl.dataset.apiUrl : '';
      }

      function showOfflineIndicator(show) {
        var indicator = document.getElementById('offline-indicator');
        if (indicator) {
          indicator.style.display = show ? 'flex' : 'none';
        }
      }

      // Tab switching
      function initTabs() {
        var tabBtns = document.querySelectorAll('.tab-btn');
        tabBtns.forEach(function(btn) {
          btn.addEventListener('click', function() {
            var tab = this.dataset.tab;
            tabBtns.forEach(function(b) {
              b.classList.remove('tab-btn--active');
              b.setAttribute('aria-selected', 'false');
            });
            this.classList.add('tab-btn--active');
            this.setAttribute('aria-selected', 'true');

            document.getElementById('editor-container').style.display = tab === 'editor' ? 'block' : 'none';
            document.getElementById('browser-container').style.display = tab === 'browser' ? 'block' : 'none';
            document.getElementById('generator-container').style.display = tab === 'generator' ? 'block' : 'none';

            if (tab === 'browser') {
              loadNotes();
            }
          });
        });
      }

      // Parse frontmatter from markdown content
      function parseFrontmatter(content) {
        var match = content.match(/^---\n([\s\S]*?)\n---\n/);
        if (!match) return { title: 'Untitled', date: null, status: 'draft', body: content };

        var frontmatter = match[1];
        var body = content.slice(match[0].length);

        var title = (frontmatter.match(/title:\s*"?([^"\n]+)"?/) || [])[1] || 'Untitled';
        var date = (frontmatter.match(/date:\s*(\S+)/) || [])[1] || null;
        var status = (frontmatter.match(/status:\s*(\S+)/) || [])[1] || 'draft';

        return { title: title.trim(), date: date, status: status, body: body };
      }

      // Cache notes in localStorage
      function cacheNotes(notes) {
        try {
          localStorage.setItem(NOTES_CACHE_KEY, JSON.stringify({
            timestamp: Date.now(),
            notes: notes
          }));
        } catch (e) {
          console.warn('Failed to cache notes:', e);
        }
      }

      function getCachedNotes() {
        try {
          var cached = localStorage.getItem(NOTES_CACHE_KEY);
          if (cached) {
            return JSON.parse(cached).notes || [];
          }
        } catch (e) {
          console.warn('Failed to read cached notes:', e);
        }
        return [];
      }

      // Load notes from API
      async function loadNotes() {
        var token = getToken();
        var apiUrl = getApiUrl();
        var loadingEl = document.getElementById('notes-loading');
        var errorEl = document.getElementById('notes-error');
        var emptyEl = document.getElementById('notes-empty');
        var gridEl = document.getElementById('notes-grid');

        loadingEl.style.display = 'flex';
        errorEl.style.display = 'none';
        emptyEl.style.display = 'none';
        gridEl.innerHTML = '';
        showOfflineIndicator(false);

        try {
          var response = await fetch(apiUrl + '/notes', {
            headers: { 'X-DM-Token': token }
          });

          if (!response.ok) throw new Error('Failed to load notes');

          var data = await response.json();
          allNotes = data.notes || [];
          cacheNotes(allNotes);
          renderNotes(allNotes);

        } catch (error) {
          console.error('Error loading notes:', error);
          var cached = getCachedNotes();
          if (cached.length > 0) {
            allNotes = cached;
            showOfflineIndicator(true);
            renderNotes(cached);
          } else {
            errorEl.textContent = 'Failed to load notes: ' + error.message;
            errorEl.style.display = 'block';
          }
        } finally {
          loadingEl.style.display = 'none';
        }
      }

      // Render notes to grid
      function renderNotes(notes) {
        var gridEl = document.getElementById('notes-grid');
        var emptyEl = document.getElementById('notes-empty');

        gridEl.innerHTML = '';

        if (notes.length === 0) {
          emptyEl.style.display = 'block';
          return;
        }

        emptyEl.style.display = 'none';

        notes.forEach(function(note) {
          var card = document.createElement('article');
          card.className = 'note-card';
          card.setAttribute('role', 'listitem');
          card.setAttribute('tabindex', '0');
          card.dataset.key = note.key;

          var date = note.date ? new Date(note.date).toLocaleDateString('en-US', {
            year: 'numeric', month: 'short', day: 'numeric'
          }) : 'Unknown date';

          var statusBadge = note.status === 'draft'
            ? '<span class="badge badge--draft">Draft</span>'
            : '';

          card.innerHTML =
            '<h3 class="note-card__title">' + escapeHtml(note.title) + '</h3>' +
            '<div class="note-card__meta">' +
              '<time>' + date + '</time>' +
              statusBadge +
            '</div>' +
            '<p class="note-card__preview">' + escapeHtml(note.preview || '') + '</p>';

          card.addEventListener('click', function() { viewNote(note.key); });
          card.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault();
              viewNote(note.key);
            }
          });

          gridEl.appendChild(card);
        });
      }

      function escapeHtml(text) {
        var div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }

      // View note in modal
      async function viewNote(key) {
        var token = getToken();
        var apiUrl = getApiUrl();
        var modal = document.getElementById('view-modal');
        var titleEl = document.getElementById('view-modal-title');
        var dateEl = document.getElementById('view-modal-date');
        var statusEl = document.getElementById('view-modal-status');
        var bodyEl = document.getElementById('view-modal-body');

        currentNoteKey = key;
        titleEl.textContent = 'Loading...';
        dateEl.textContent = '';
        statusEl.innerHTML = '';
        bodyEl.innerHTML = '<p>Loading note content...</p>';
        modal.style.display = 'flex';

        try {
          var response = await fetch(apiUrl + '/notes/' + encodeURIComponent(key), {
            headers: { 'X-DM-Token': token }
          });

          if (!response.ok) throw new Error('Failed to load note');

          var data = await response.json();
          var parsed = parseFrontmatter(data.content);

          titleEl.textContent = parsed.title;
          dateEl.textContent = parsed.date
            ? new Date(parsed.date).toLocaleDateString('en-US', {
                year: 'numeric', month: 'long', day: 'numeric'
              })
            : '';

          var statusClass = parsed.status === 'draft' ? 'status-badge--draft' : 'status-badge--published';
          statusEl.innerHTML = '<span class="status-badge ' + statusClass + '">' + parsed.status + '</span>';

          // Render markdown with syntax highlighting
          if (window.marked && window.DOMPurify) {
            window.marked.setOptions({
              highlight: function(code, lang) {
                if (window.hljs && lang && window.hljs.getLanguage(lang)) {
                  return window.hljs.highlight(code, { language: lang }).value;
                }
                return code;
              }
            });
            var rendered = window.marked.parse(parsed.body);
            bodyEl.innerHTML = window.DOMPurify.sanitize(rendered);
          } else {
            bodyEl.textContent = parsed.body;
          }

        } catch (error) {
          titleEl.textContent = 'Error';
          bodyEl.innerHTML = '<p class="error">Failed to load note: ' + escapeHtml(error.message) + '</p>';
        }
      }

      // Download note
      function downloadNote() {
        if (!currentNoteKey) return;
        var note = allNotes.find(function(n) { return n.key === currentNoteKey; });
        if (!note) return;

        var filename = currentNoteKey.replace('dm-notes/', '');
        var token = getToken();
        var apiUrl = getApiUrl();

        fetch(apiUrl + '/notes/' + encodeURIComponent(currentNoteKey), {
          headers: { 'X-DM-Token': token }
        })
        .then(function(r) { return r.json(); })
        .then(function(data) {
          var blob = new Blob([data.content], { type: 'text/markdown' });
          var url = URL.createObjectURL(blob);
          var a = document.createElement('a');
          a.href = url;
          a.download = filename;
          a.click();
          URL.revokeObjectURL(url);
        });
      }

      // Delete note
      function showDeleteConfirm() {
        var note = allNotes.find(function(n) { return n.key === currentNoteKey; });
        if (!note) return;

        document.getElementById('delete-modal-title').textContent = note.title;
        document.getElementById('view-modal').style.display = 'none';
        document.getElementById('delete-modal').style.display = 'flex';
      }

      async function confirmDelete() {
        if (!currentNoteKey) return;

        var token = getToken();
        var apiUrl = getApiUrl();
        var confirmBtn = document.getElementById('confirm-delete-btn');

        confirmBtn.disabled = true;
        confirmBtn.textContent = 'Deleting...';

        try {
          var response = await fetch(apiUrl + '/notes/' + encodeURIComponent(currentNoteKey), {
            method: 'DELETE',
            headers: { 'X-DM-Token': token }
          });

          if (!response.ok) throw new Error('Failed to delete note');

          closeModals();
          loadNotes();

        } catch (error) {
          alert('Failed to delete note: ' + error.message);
        } finally {
          confirmBtn.disabled = false;
          confirmBtn.textContent = 'Delete';
        }
      }

      function closeModals() {
        document.getElementById('view-modal').style.display = 'none';
        document.getElementById('delete-modal').style.display = 'none';
        currentNoteKey = null;
      }

      // Search and sort
      function filterNotes(query) {
        var filtered = allNotes.filter(function(note) {
          return note.title.toLowerCase().includes(query.toLowerCase());
        });
        renderNotes(filtered);
      }

      function sortNotes(sortBy) {
        var sorted = allNotes.slice();
        switch (sortBy) {
          case 'date-desc':
            sorted.sort(function(a, b) { return new Date(b.date) - new Date(a.date); });
            break;
          case 'date-asc':
            sorted.sort(function(a, b) { return new Date(a.date) - new Date(b.date); });
            break;
          case 'title-asc':
            sorted.sort(function(a, b) { return a.title.localeCompare(b.title); });
            break;
          case 'title-desc':
            sorted.sort(function(a, b) { return b.title.localeCompare(a.title); });
            break;
        }
        allNotes = sorted;
        renderNotes(sorted);
      }

      function initBrowser() {
        var token = getToken();
        if (!token) return;

        initTabs();

        // Modal close handlers
        document.querySelectorAll('[data-close-modal]').forEach(function(btn) {
          btn.addEventListener('click', closeModals);
        });

        document.querySelectorAll('.modal__backdrop').forEach(function(backdrop) {
          backdrop.addEventListener('click', closeModals);
        });

        document.addEventListener('keydown', function(e) {
          if (e.key === 'Escape') closeModals();
        });

        // Note action handlers
        document.getElementById('download-note-btn').addEventListener('click', downloadNote);
        document.getElementById('delete-note-btn').addEventListener('click', showDeleteConfirm);
        document.getElementById('confirm-delete-btn').addEventListener('click', confirmDelete);

        // Search and sort handlers
        var searchInput = document.getElementById('notes-search');
        var sortSelect = document.getElementById('notes-sort');

        var searchTimeout;
        searchInput.addEventListener('input', function() {
          clearTimeout(searchTimeout);
          var query = this.value;
          searchTimeout = setTimeout(function() {
            filterNotes(query);
          }, 300);
        });

        sortSelect.addEventListener('change', function() {
          sortNotes(this.value);
        });

        // Offline detection
        window.addEventListener('online', function() {
          showOfflineIndicator(false);
          loadNotes();
        });

        window.addEventListener('offline', function() {
          showOfflineIndicator(true);
        });
      }

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initBrowser);
      } else {
        initBrowser();
      }
    })();
  </script>

  <!-- Generator Script -->
  <script is:inline>
    (function() {
      var currentResult = null;

      function getToken() {
        var params = new URLSearchParams(window.location.search);
        return params.get('token');
      }

      function getApiUrl() {
        var configEl = document.getElementById('config');
        return configEl ? configEl.dataset.apiUrl : '';
      }

      function escapeHtml(text) {
        var div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }

      function showLoading(show) {
        document.getElementById('generator-loading').style.display = show ? 'flex' : 'none';
      }

      function showError(message) {
        var errorEl = document.getElementById('generator-error');
        if (message) {
          errorEl.textContent = message;
          errorEl.style.display = 'block';
        } else {
          errorEl.style.display = 'none';
        }
      }

      function renderEntityPreview(result) {
        var previewEl = document.getElementById('entity-card-preview');
        var fm = result.frontmatter || {};
        // Note: All content is sanitized via escapeHtml() before innerHTML insertion

        // Build entity type and subtype badges
        var typeTag = '<span class="entity-tag entity-tag--type">' + escapeHtml(result.entityType || 'unknown') + '</span>';
        var subtypeTag = fm.subtype
          ? '<span class="entity-tag entity-tag--subtype">' + escapeHtml(fm.subtype) + '</span>'
          : '';

        // Build status badge if not active
        var statusTag = (fm.status && fm.status !== 'active')
          ? '<span class="entity-tag entity-tag--status entity-tag--' + escapeHtml(fm.status) + '">' + escapeHtml(fm.status) + '</span>'
          : '';

        // Helper to render array as list
        function renderList(arr) {
          if (!arr || !arr.length) return null;
          return arr.map(function(item) { return escapeHtml(item); }).join(', ');
        }

        // Build key attribute tags based on entity type
        var attrTags = '';
        if (result.entityType === 'character') {
          if (fm.race) attrTags += '<span class="entity-tag">' + escapeHtml(fm.race) + '</span>';
          if (fm.class) attrTags += '<span class="entity-tag">' + escapeHtml(fm.class) + (fm.subclass ? ' (' + escapeHtml(fm.subclass) + ')' : '') + '</span>';
          if (fm.level) attrTags += '<span class="entity-tag">Lvl ' + escapeHtml(String(fm.level)) + '</span>';
          if (fm.alignment) attrTags += '<span class="entity-tag">' + escapeHtml(fm.alignment) + '</span>';
        } else if (result.entityType === 'enemy') {
          if (fm.cr) attrTags += '<span class="entity-tag">CR ' + escapeHtml(fm.cr) + '</span>';
          if (fm.creatureType) attrTags += '<span class="entity-tag">' + escapeHtml(fm.creatureType) + '</span>';
          if (fm.baseMonster) attrTags += '<span class="entity-tag">' + escapeHtml(fm.baseMonster) + '</span>';
        } else if (result.entityType === 'item') {
          if (fm.rarity) attrTags += '<span class="entity-tag entity-tag--' + escapeHtml(fm.rarity) + '">' + escapeHtml(fm.rarity) + '</span>';
          if (fm.attunement) attrTags += '<span class="entity-tag">requires attunement</span>';
          if (fm.baseItem) attrTags += '<span class="entity-tag">' + escapeHtml(fm.baseItem) + '</span>';
        } else if (result.entityType === 'location') {
          if (fm.terrain) attrTags += '<span class="entity-tag">' + escapeHtml(fm.terrain) + '</span>';
          if (fm.climate) attrTags += '<span class="entity-tag">' + escapeHtml(fm.climate) + '</span>';
          if (fm.population) attrTags += '<span class="entity-tag">Pop: ' + escapeHtml(fm.population) + '</span>';
        } else if (result.entityType === 'faction') {
          if (fm.leader) attrTags += '<span class="entity-tag">Led by: ' + escapeHtml(fm.leader) + '</span>';
        }

        // Build abilities section
        var abilitiesHtml = '';
        if (fm.abilities && fm.abilities.length > 0) {
          abilitiesHtml = '<div class="entity-section"><h4>Abilities</h4><ul class="entity-abilities">';
          fm.abilities.forEach(function(ability) {
            abilitiesHtml += '<li>' + escapeHtml(ability) + '</li>';
          });
          abilitiesHtml += '</ul></div>';
        }

        // Build relationships section
        var relationshipsHtml = '';
        if (fm.relationships && fm.relationships.length > 0) {
          relationshipsHtml = '<div class="entity-section"><h4>Relationships</h4><ul class="entity-relationships">';
          fm.relationships.forEach(function(rel) {
            var relText = '<strong>' + escapeHtml(rel.type) + '</strong>: ' + escapeHtml(rel.entity);
            if (rel.note) relText += ' <span class="rel-note">(' + escapeHtml(rel.note) + ')</span>';
            relationshipsHtml += '<li>' + relText + '</li>';
          });
          relationshipsHtml += '</ul></div>';
        }

        // Build comprehensive type-specific details
        var detailsHtml = '<div class="entity-section entity-details"><h4>Details</h4><dl>';
        var hasDetails = false;

        if (result.entityType === 'character') {
          if (fm.background) { detailsHtml += '<dt>Background:</dt><dd>' + escapeHtml(fm.background) + '</dd>'; hasDetails = true; }
          if (fm.faction) { detailsHtml += '<dt>Faction:</dt><dd>' + escapeHtml(fm.faction) + '</dd>'; hasDetails = true; }
          if (fm.location) { detailsHtml += '<dt>Location:</dt><dd>' + escapeHtml(fm.location) + '</dd>'; hasDetails = true; }
          if (fm.homeLocation) { detailsHtml += '<dt>Home:</dt><dd>' + escapeHtml(fm.homeLocation) + '</dd>'; hasDetails = true; }
          if (fm.player) { detailsHtml += '<dt>Player:</dt><dd>' + escapeHtml(fm.player) + '</dd>'; hasDetails = true; }
          if (fm.ideals && fm.ideals.length) { detailsHtml += '<dt>Ideals:</dt><dd>' + renderList(fm.ideals) + '</dd>'; hasDetails = true; }
          if (fm.bonds && fm.bonds.length) { detailsHtml += '<dt>Bonds:</dt><dd>' + renderList(fm.bonds) + '</dd>'; hasDetails = true; }
          if (fm.flaws && fm.flaws.length) { detailsHtml += '<dt>Flaws:</dt><dd>' + renderList(fm.flaws) + '</dd>'; hasDetails = true; }
        } else if (result.entityType === 'enemy') {
          if (fm.faction) { detailsHtml += '<dt>Faction:</dt><dd>' + escapeHtml(fm.faction) + '</dd>'; hasDetails = true; }
          if (fm.lair) { detailsHtml += '<dt>Lair:</dt><dd>' + escapeHtml(fm.lair) + '</dd>'; hasDetails = true; }
          if (fm.territory && fm.territory.length) { detailsHtml += '<dt>Territory:</dt><dd>' + renderList(fm.territory) + '</dd>'; hasDetails = true; }
          if (fm.customizations && fm.customizations.length) { detailsHtml += '<dt>Customizations:</dt><dd>' + renderList(fm.customizations) + '</dd>'; hasDetails = true; }
          if (fm.legendaryActions && fm.legendaryActions.length) { detailsHtml += '<dt>Legendary:</dt><dd>' + renderList(fm.legendaryActions) + '</dd>'; hasDetails = true; }
          if (fm.lairActions && fm.lairActions.length) { detailsHtml += '<dt>Lair Actions:</dt><dd>' + renderList(fm.lairActions) + '</dd>'; hasDetails = true; }
        } else if (result.entityType === 'item') {
          if (fm.currentOwner) { detailsHtml += '<dt>Owner:</dt><dd>' + escapeHtml(fm.currentOwner) + '</dd>'; hasDetails = true; }
          if (fm.location) { detailsHtml += '<dt>Location:</dt><dd>' + escapeHtml(fm.location) + '</dd>'; hasDetails = true; }
          if (fm.properties && fm.properties.length) { detailsHtml += '<dt>Properties:</dt><dd>' + renderList(fm.properties) + '</dd>'; hasDetails = true; }
          if (fm.attunementRequirements) { detailsHtml += '<dt>Attunement:</dt><dd>' + escapeHtml(fm.attunementRequirements) + '</dd>'; hasDetails = true; }
          if (fm.charges) { detailsHtml += '<dt>Charges:</dt><dd>' + escapeHtml(String(fm.charges)) + (fm.maxCharges ? '/' + escapeHtml(String(fm.maxCharges)) : '') + '</dd>'; hasDetails = true; }
          if (fm.creator) { detailsHtml += '<dt>Creator:</dt><dd>' + escapeHtml(fm.creator) + '</dd>'; hasDetails = true; }
          if (fm.significance) { detailsHtml += '<dt>Significance:</dt><dd>' + escapeHtml(fm.significance) + '</dd>'; hasDetails = true; }
          if (fm.secrets && fm.secrets.length) { detailsHtml += '<dt>Secrets:</dt><dd class="dm-only">' + renderList(fm.secrets) + '</dd>'; hasDetails = true; }
        } else if (result.entityType === 'location') {
          if (fm.parentLocation) { detailsHtml += '<dt>Part of:</dt><dd>' + escapeHtml(fm.parentLocation) + '</dd>'; hasDetails = true; }
          if (fm.controlledBy) { detailsHtml += '<dt>Controlled by:</dt><dd>' + escapeHtml(fm.controlledBy) + '</dd>'; hasDetails = true; }
          if (fm.childLocations && fm.childLocations.length) { detailsHtml += '<dt>Contains:</dt><dd>' + renderList(fm.childLocations) + '</dd>'; hasDetails = true; }
          if (fm.pointsOfInterest && fm.pointsOfInterest.length) { detailsHtml += '<dt>Points of Interest:</dt><dd>' + renderList(fm.pointsOfInterest) + '</dd>'; hasDetails = true; }
          if (fm.dungeonLevel) { detailsHtml += '<dt>Dungeon Level:</dt><dd>' + escapeHtml(String(fm.dungeonLevel)) + '</dd>'; hasDetails = true; }
          if (fm.notableEvents && fm.notableEvents.length) { detailsHtml += '<dt>Notable Events:</dt><dd>' + renderList(fm.notableEvents) + '</dd>'; hasDetails = true; }
          if (fm.secrets && fm.secrets.length) { detailsHtml += '<dt>Secrets:</dt><dd class="dm-only">' + renderList(fm.secrets) + '</dd>'; hasDetails = true; }
        } else if (result.entityType === 'faction') {
          if (fm.headquarters) { detailsHtml += '<dt>HQ:</dt><dd>' + escapeHtml(fm.headquarters) + '</dd>'; hasDetails = true; }
          if (fm.parentOrganization) { detailsHtml += '<dt>Parent Org:</dt><dd>' + escapeHtml(fm.parentOrganization) + '</dd>'; hasDetails = true; }
          if (fm.symbol) { detailsHtml += '<dt>Symbol:</dt><dd>' + escapeHtml(fm.symbol) + '</dd>'; hasDetails = true; }
          if (fm.motto) { detailsHtml += '<dt>Motto:</dt><dd>"' + escapeHtml(fm.motto) + '"</dd>'; hasDetails = true; }
          if (fm.goals && fm.goals.length) { detailsHtml += '<dt>Goals:</dt><dd>' + renderList(fm.goals) + '</dd>'; hasDetails = true; }
          if (fm.methods && fm.methods.length) { detailsHtml += '<dt>Methods:</dt><dd>' + renderList(fm.methods) + '</dd>'; hasDetails = true; }
          if (fm.territory && fm.territory.length) { detailsHtml += '<dt>Territory:</dt><dd>' + renderList(fm.territory) + '</dd>'; hasDetails = true; }
          if (fm.allies && fm.allies.length) { detailsHtml += '<dt>Allies:</dt><dd>' + renderList(fm.allies) + '</dd>'; hasDetails = true; }
          if (fm.enemies && fm.enemies.length) { detailsHtml += '<dt>Enemies:</dt><dd>' + renderList(fm.enemies) + '</dd>'; hasDetails = true; }
          if (fm.notableMembers && fm.notableMembers.length) { detailsHtml += '<dt>Members:</dt><dd>' + renderList(fm.notableMembers) + '</dd>'; hasDetails = true; }
          if (fm.resources && fm.resources.length) { detailsHtml += '<dt>Resources:</dt><dd>' + renderList(fm.resources) + '</dd>'; hasDetails = true; }
          if (fm.secrets && fm.secrets.length) { detailsHtml += '<dt>Secrets:</dt><dd class="dm-only">' + renderList(fm.secrets) + '</dd>'; hasDetails = true; }
        }
        detailsHtml += '</dl></div>';
        if (!hasDetails) detailsHtml = '';

        // Build tags section
        var tagsHtml = '';
        if (fm.tags && fm.tags.length > 0) {
          tagsHtml = '<div class="entity-tags">';
          fm.tags.forEach(function(tag) {
            tagsHtml += '<span class="entity-tag entity-tag--user">' + escapeHtml(tag) + '</span>';
          });
          tagsHtml += '</div>';
        }

        // Build full markdown content with basic rendering
        var markdownHtml = '';
        if (result.markdown) {
          // Simple markdown to HTML conversion
          var md = result.markdown;
          // Split into lines and process
          var htmlLines = [];
          var inList = false;
          md.split('\\n').forEach(function(line) {
            var trimmed = line.trim();
            if (!trimmed) {
              if (inList) { htmlLines.push('</ul>'); inList = false; }
              return;
            }
            // Skip the title (# Entity Name) since we already show it
            if (trimmed.startsWith('# ')) return;
            // H2 headers become section headers
            if (trimmed.startsWith('## ')) {
              if (inList) { htmlLines.push('</ul>'); inList = false; }
              htmlLines.push('<h4 class="md-section">' + escapeHtml(trimmed.substring(3)) + '</h4>');
              return;
            }
            // H3 headers
            if (trimmed.startsWith('### ')) {
              if (inList) { htmlLines.push('</ul>'); inList = false; }
              htmlLines.push('<h5 class="md-subsection">' + escapeHtml(trimmed.substring(4)) + '</h5>');
              return;
            }
            // List items
            if (trimmed.startsWith('- ') || trimmed.startsWith('* ')) {
              if (!inList) { htmlLines.push('<ul class="md-list">'); inList = true; }
              var itemText = escapeHtml(trimmed.substring(2));
              // Convert **bold** markers after escaping
              itemText = itemText.replace(/\\*\\*([^*]+)\\*\\*/g, '<strong>$1</strong>');
              htmlLines.push('<li>' + itemText + '</li>');
              return;
            }
            // Regular paragraph
            if (inList) { htmlLines.push('</ul>'); inList = false; }
            var paraText = escapeHtml(trimmed);
            // Convert **bold** markers after escaping
            paraText = paraText.replace(/\\*\\*([^*]+)\\*\\*/g, '<strong>$1</strong>');
            htmlLines.push('<p>' + paraText + '</p>');
          });
          if (inList) htmlLines.push('</ul>');

          if (htmlLines.length > 0) {
            markdownHtml = '<div class="entity-section entity-markdown-full">' + htmlLines.join('') + '</div>';
          }
        }

        previewEl.innerHTML =
          '<h3 class="entity-name">' + escapeHtml(fm.name || 'Unnamed Entity') + '</h3>' +
          '<div class="entity-meta">' + typeTag + subtypeTag + statusTag + attrTags + '</div>' +
          '<p class="entity-description">' + escapeHtml(fm.description || 'No description') + '</p>' +
          abilitiesHtml +
          relationshipsHtml +
          detailsHtml +
          markdownHtml +
          tagsHtml;
      }

      function renderConfidenceBadge(confidence) {
        var badgeEl = document.getElementById('confidence-badge');
        var level = confidence >= 80 ? 'high' : confidence >= 50 ? 'medium' : 'low';
        badgeEl.textContent = 'Confidence: ' + confidence + '%';
        badgeEl.className = 'confidence-badge confidence-badge--' + level;
      }

      function renderSuggestions(suggestions) {
        var panel = document.getElementById('suggestions-panel');
        var list = document.getElementById('suggestions-list');

        if (!suggestions || suggestions.length === 0) {
          panel.style.display = 'none';
          return;
        }

        list.innerHTML = '';
        suggestions.forEach(function(s) {
          var li = document.createElement('li');
          li.textContent = s;
          list.appendChild(li);
        });
        panel.style.display = 'block';
      }

      async function generateEntity() {
        var token = getToken();
        var apiUrl = getApiUrl();

        if (!token || !apiUrl) {
          showError('Missing token or API configuration');
          return;
        }

        var input = document.getElementById('entity-input').value.trim();
        if (!input) {
          showError('Please enter an entity description');
          return;
        }

        var hint = document.getElementById('entity-type-hint').value || null;

        var generateBtn = document.getElementById('generate-btn');
        generateBtn.disabled = true;
        showLoading(true);
        showError(null);
        document.getElementById('generator-preview').style.display = 'none';

        try {
          var response = await fetch(apiUrl + '/generate-entity', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'X-DM-Token': token
            },
            body: JSON.stringify({ input: input, hint: hint })
          });

          if (!response.ok) {
            var errorData = await response.json().catch(function() { return {}; });
            throw new Error(errorData.error || 'Generation failed');
          }

          var result = await response.json();
          currentResult = result;

          // Render preview
          renderEntityPreview(result);
          renderConfidenceBadge(result.confidence || 80);
          renderSuggestions(result.suggestions);

          // Populate YAML editor
          document.getElementById('yaml-editor').value = result.fullContent || '';

          document.getElementById('generator-preview').style.display = 'block';

        } catch (error) {
          showError('Error: ' + error.message);
        } finally {
          showLoading(false);
          generateBtn.disabled = false;
        }
      }

      function copyToClipboard() {
        var content = document.getElementById('yaml-editor').value;
        navigator.clipboard.writeText(content).then(function() {
          var btn = document.getElementById('copy-btn');
          var originalText = btn.textContent;
          btn.textContent = 'Copied!';
          setTimeout(function() { btn.textContent = originalText; }, 2000);
        }).catch(function(err) {
          alert('Failed to copy: ' + err.message);
        });
      }

      function downloadFile() {
        if (!currentResult) return;

        var content = document.getElementById('yaml-editor').value;
        var slug = currentResult.slug || 'entity';
        var filename = slug + '.md';

        var blob = new Blob([content], { type: 'text/markdown' });
        var url = URL.createObjectURL(blob);
        var a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);
      }

      function initGenerator() {
        var token = getToken();
        if (!token) return;

        document.getElementById('generate-btn').addEventListener('click', generateEntity);
        document.getElementById('regenerate-btn').addEventListener('click', generateEntity);
        document.getElementById('copy-btn').addEventListener('click', copyToClipboard);
        document.getElementById('download-btn').addEventListener('click', downloadFile);

        // Allow Enter key to generate
        document.getElementById('entity-input').addEventListener('keydown', function(e) {
          if (e.key === 'Enter' && e.ctrlKey) {
            e.preventDefault();
            generateEntity();
          }
        });
      }

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initGenerator);
      } else {
        initGenerator();
      }
    })();
  </script>

  <style>
    /* ===========================================
       Main Page Layout
       =========================================== */
    .dm-notes {
      min-height: 80vh;
    }

    /* Accessibility utility */
    .visually-hidden {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    /* ===========================================
       Dynamic Content Styles
       These styles apply to elements created by JavaScript
       =========================================== */

    /* Note cards in the browser grid */
    .note-card {
      background: var(--color-bg-secondary);
      border: 1px solid var(--color-border);
      border-radius: var(--radius-lg);
      padding: var(--space-lg);
      cursor: pointer;
      transition: all var(--transition-fast);
    }

    .note-card:hover,
    .note-card:focus {
      border-color: var(--color-gold);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }

    .note-card:focus {
      outline: 2px solid var(--color-gold);
      outline-offset: 2px;
    }

    .note-card__title {
      font-family: var(--font-display);
      color: var(--color-gold);
      margin: 0 0 var(--space-sm);
      font-size: var(--text-lg);
    }

    .note-card__meta {
      display: flex;
      align-items: center;
      gap: var(--space-sm);
      font-size: var(--text-sm);
      color: var(--color-text-muted);
      margin-bottom: var(--space-sm);
    }

    .note-card__preview {
      color: var(--color-text-secondary);
      font-size: var(--text-sm);
      margin: 0;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    /* Badge styles */
    .badge {
      font-size: var(--text-xs);
      padding: 2px var(--space-xs);
      border-radius: var(--radius-sm);
      font-weight: 600;
      text-transform: uppercase;
    }

    .badge--draft {
      background: rgba(234, 179, 8, 0.2);
      color: var(--color-warning, #eab308);
    }

    /* Markdown content rendered in modals */
    .markdown-content {
      line-height: 1.7;
    }

    .markdown-content h1,
    .markdown-content h2,
    .markdown-content h3,
    .markdown-content h4 {
      font-family: var(--font-display);
      color: var(--color-gold);
      margin-top: var(--space-lg);
      margin-bottom: var(--space-sm);
    }

    .markdown-content h1 { font-size: var(--text-2xl); }
    .markdown-content h2 { font-size: var(--text-xl); }
    .markdown-content h3 { font-size: var(--text-lg); }

    .markdown-content p {
      margin-bottom: var(--space-md);
    }

    .markdown-content ul,
    .markdown-content ol {
      margin-bottom: var(--space-md);
      padding-left: var(--space-lg);
    }

    .markdown-content li {
      margin-bottom: var(--space-xs);
    }

    .markdown-content pre {
      background: var(--color-bg-secondary);
      border: 1px solid var(--color-border);
      border-radius: var(--radius-md);
      padding: var(--space-md);
      overflow-x: auto;
      margin-bottom: var(--space-md);
    }

    .markdown-content code {
      font-family: var(--font-mono);
      font-size: 0.9em;
    }

    .markdown-content :not(pre) > code {
      background: var(--color-bg-secondary);
      padding: 2px var(--space-xs);
      border-radius: var(--radius-sm);
    }

    .markdown-content blockquote {
      border-left: 4px solid var(--color-gold);
      margin: var(--space-md) 0;
      padding-left: var(--space-md);
      color: var(--color-text-muted);
      font-style: italic;
    }

    .markdown-content table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: var(--space-md);
    }

    .markdown-content th,
    .markdown-content td {
      border: 1px solid var(--color-border);
      padding: var(--space-sm);
      text-align: left;
    }

    .markdown-content th {
      background: var(--color-bg-secondary);
      font-weight: 600;
    }

    .markdown-content hr {
      border: none;
      border-top: 1px solid var(--color-border);
      margin: var(--space-lg) 0;
    }
  </style>
</BaseLayout>
