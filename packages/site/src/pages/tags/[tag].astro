---
/**
 * Tag Detail Page
 *
 * Shows all entities with a specific tag.
 * Groups results by entity type for easy browsing.
 */

import BaseLayout from '@layouts/BaseLayout.astro';
import BreadcrumbNav from '@components/BreadcrumbNav.astro';
import { getCollection } from 'astro:content';

export async function getStaticPaths() {
  // Fetch all collections that have tags
  const [characters, enemies, locations, factions, items, blogs] = await Promise.all([
    getCollection('characters'),
    getCollection('enemies'),
    getCollection('locations'),
    getCollection('factions'),
    getCollection('items'),
    getCollection('blog'),
  ]);

  // Type aliases
  type CharacterEntry = typeof characters[0];
  type EnemyEntry = typeof enemies[0];
  type LocationEntry = typeof locations[0];
  type FactionEntry = typeof factions[0];
  type ItemEntry = typeof items[0];
  type BlogEntry = typeof blogs[0];

  // Build tag -> entities mapping
  const tagMap = new Map<string, Array<{
    name: string;
    path: string;
    type: string;
    description?: string;
  }>>();

  function addEntity(
    tags: string[] | undefined,
    entityName: string,
    entityPath: string,
    entityType: string,
    description?: string
  ) {
    if (!tags) return;
    for (const tag of tags) {
      const normalized = tag.toLowerCase().trim();
      if (!tagMap.has(normalized)) {
        tagMap.set(normalized, []);
      }
      tagMap.get(normalized)!.push({
        name: entityName,
        path: entityPath,
        type: entityType,
        description,
      });
    }
  }

  // Process all entities
  characters.forEach((e: CharacterEntry) => addEntity(e.data.tags, e.data.name, `/campaign/characters/${e.id}`, 'character', e.data.description));
  enemies.forEach((e: EnemyEntry) => addEntity(e.data.tags, e.data.name, `/campaign/enemies/${e.id}`, 'enemy', e.data.description));
  locations.forEach((e: LocationEntry) => addEntity(e.data.tags, e.data.name, `/campaign/locations/${e.id}`, 'location', e.data.description));
  factions.forEach((e: FactionEntry) => addEntity(e.data.tags, e.data.name, `/campaign/factions/${e.id}`, 'faction', e.data.description));
  items.forEach((e: ItemEntry) => addEntity(e.data.tags, e.data.name, `/campaign/items/${e.id}`, 'item', e.data.description));
  blogs.forEach((e: BlogEntry) => addEntity(e.data.tags, e.data.title, `/blog/${e.id}`, 'blog', e.data.description));

  return Array.from(tagMap.entries()).map(([tag, entities]) => ({
    params: { tag },
    props: { tag, entities },
  }));
}

interface Entity {
  name: string;
  path: string;
  type: string;
  description?: string;
}

interface Props {
  tag: string;
  entities: Entity[];
}

const { tag, entities } = Astro.props;

// Group entities by type
const groupedEntities = entities.reduce((acc, entity) => {
  if (!acc[entity.type]) {
    acc[entity.type] = [];
  }
  acc[entity.type].push(entity);
  return acc;
}, {} as Record<string, Entity[]>);

// Sort each group alphabetically
Object.values(groupedEntities).forEach(group => {
  group.sort((a, b) => a.name.localeCompare(b.name));
});

// Order of entity types for display
const typeOrder = ['character', 'enemy', 'location', 'faction', 'item', 'blog'];
const typeLabels: Record<string, string> = {
  character: 'Characters',
  enemy: 'Enemies',
  location: 'Locations',
  faction: 'Factions',
  item: 'Items',
  blog: 'Blog Posts',
};

const typeColors: Record<string, string> = {
  character: 'var(--color-gold)',
  enemy: 'var(--color-error)',
  location: 'var(--color-accent)',
  faction: 'var(--color-warning)',
  item: 'var(--color-success)',
  blog: 'var(--color-text-muted)',
};
---

<BaseLayout
  title={`Tag: ${tag} - Campaign Reference`}
  description={`Browse all campaign content tagged with "${tag}"`}
>
  <div class="container">
    <BreadcrumbNav items={[
      { label: 'Home', href: '/' },
      { label: 'Tags', href: '/tags' },
      { label: tag },
    ]} />

    <header class="page-header">
      <p class="page-label">Tag</p>
      <h1 class="page-title">#{tag}</h1>
      <p class="page-description">
        {entities.length} {entities.length === 1 ? 'entry' : 'entries'} tagged
      </p>
    </header>

    <div class="tag-results">
      {typeOrder.map(type => {
        const group = groupedEntities[type];
        if (!group || group.length === 0) return null;

        return (
          <section class="result-section" data-type={type}>
            <h2 class="section-title" style={`border-color: ${typeColors[type]}`}>
              {typeLabels[type]}
              <span class="section-count">({group.length})</span>
            </h2>
            <ul class="result-list">
              {group.map(entity => (
                <li class="result-item">
                  <a href={entity.path} class="result-link">
                    <span class="result-name">{entity.name}</span>
                    {entity.description && (
                      <span class="result-description">
                        {entity.description.slice(0, 100)}{entity.description.length > 100 ? '...' : ''}
                      </span>
                    )}
                  </a>
                </li>
              ))}
            </ul>
          </section>
        );
      })}
    </div>

    <footer class="tag-footer">
      <a href="/tags" class="back-link">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <polyline points="15 18 9 12 15 6"></polyline>
        </svg>
        Back to All Tags
      </a>
    </footer>
  </div>
</BaseLayout>

<style>
  .page-header {
    text-align: center;
    padding: var(--space-xl) 0 var(--space-lg);
    margin-bottom: var(--space-xl);
    border-bottom: 2px solid var(--color-border);
  }

  .page-label {
    font-size: var(--text-xs);
    font-weight: 600;
    color: var(--color-text-muted);
    text-transform: uppercase;
    letter-spacing: 0.1em;
    margin: 0 0 var(--space-xs);
  }

  .page-title {
    font-size: var(--text-4xl);
    color: var(--color-gold);
    margin: 0 0 var(--space-sm);
  }

  .page-description {
    color: var(--color-text-secondary);
    font-size: var(--text-lg);
    margin: 0;
  }

  /* Results */
  .tag-results {
    display: flex;
    flex-direction: column;
    gap: var(--space-2xl);
    margin-bottom: var(--space-2xl);
  }

  .result-section {
    background: var(--color-bg-secondary);
    border-radius: var(--radius-lg);
    padding: var(--space-lg);
  }

  .section-title {
    font-family: var(--font-display);
    font-size: var(--text-lg);
    margin: 0 0 var(--space-md);
    padding-bottom: var(--space-sm);
    border-bottom: 2px solid var(--color-gold);
    display: flex;
    align-items: center;
    gap: var(--space-sm);
  }

  .section-count {
    font-size: var(--text-sm);
    font-weight: normal;
    color: var(--color-text-muted);
  }

  .result-list {
    list-style: none;
    padding: 0;
    margin: 0;
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
    gap: var(--space-sm);
  }

  .result-item {
    background: var(--color-bg);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-md);
    transition: all var(--transition-fast);
  }

  .result-item:hover {
    border-color: var(--color-gold);
  }

  .result-link {
    display: flex;
    flex-direction: column;
    gap: var(--space-xs);
    padding: var(--space-md);
    text-decoration: none;
    color: inherit;
  }

  .result-name {
    font-weight: 600;
    color: var(--color-text);
  }

  .result-item:hover .result-name {
    color: var(--color-gold);
  }

  .result-description {
    font-size: var(--text-sm);
    color: var(--color-text-muted);
    line-height: 1.4;
  }

  /* Footer */
  .tag-footer {
    padding-top: var(--space-xl);
    border-top: 1px solid var(--color-border);
  }

  .back-link {
    display: inline-flex;
    align-items: center;
    gap: var(--space-sm);
    padding: var(--space-sm) var(--space-md);
    background: var(--color-bg-secondary);
    border-radius: var(--radius-md);
    color: var(--color-text-secondary);
    text-decoration: none;
    font-weight: 500;
    transition: all var(--transition-fast);
  }

  .back-link:hover {
    background: var(--color-bg-tertiary);
    color: var(--color-text);
  }

  @media (max-width: 640px) {
    .result-list {
      grid-template-columns: 1fr;
    }
  }
</style>
